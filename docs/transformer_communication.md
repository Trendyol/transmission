# Transformer Communication

Transformers in the Transmission library can communicate with each other in several ways. This document explains the different communication mechanisms and when to use each one.

## Communication Mechanisms

Transmission provides several mechanisms for communication between Transformers:

1. **Broadcast Communication**: Using Signals and Effects
2. **Data Access**: Using DataHolders
3. **Direct Communication**: Using Computations and Executions

## 1. Broadcast Communication

The most basic form of communication is through the broadcast of Signals and Effects:

### Signal Broadcast

Signals are typically sent from outside the Transmission network (e.g., from UI) and are broadcast to all Transformers:

```kotlin
// In a UI component or other external source
router.process(MySignal)
```

All Transformers that have registered a handler for `MySignal` will receive it.

### Effect Broadcast

Effects are generated by Transformers and are broadcast to all other Transformers:

```kotlin
// In a Transformer handler
onSignal<MySignal> {
    // Process signal
    publish(MyEffect)
}

// In another Transformer
onEffect<MyEffect> {
    // React to the effect
}
```

This provides a way for Transformers to notify other Transformers about events or state changes without direct coupling.

## 2. Data Access

Transformers can share data using DataHolders:

```kotlin
// In one Transformer
private val dataHolder = dataHolder<MyData?>(
    initialValue = null,
    contract = myDataContract
)

// Update the data
dataHolder.update { MyData("new value") }

// In another Transformer
val data = requestHelper.getData(myDataContract)
```

This mechanism is useful when one Transformer needs to access data maintained by another Transformer.

## 3. Direct Communication

For more direct communication, Transformers can use Computations and Executions:

### Computations

Computations allow one Transformer to request a value from another Transformer:

```kotlin
// In the provider Transformer
override val computations: Computations = createComputations {
    register(myComputationContract) {
        // Compute and return a value
        42
    }
}

// In the requester Transformer
val result = requestHelper.compute(myComputationContract)
```

Computations can also take arguments:

```kotlin
// In the provider Transformer
override val computations: Computations = createComputations {
    register(myComputationWithArgsContract) { arg: String ->
        // Compute using the argument
        arg.length
    }
}

// In the requester Transformer
val result = requestHelper.compute(myComputationWithArgsContract, "hello")
```

### Executions

Executions allow one Transformer to trigger an action in another Transformer without expecting a return value:

```kotlin
// In the provider Transformer
override val executions: Executions = createExecutions {
    register(myExecutionContract) {
        // Perform an action
        logger.log("Execution triggered")
    }
}

// In the requester Transformer
requestHelper.execute(myExecutionContract)
```

Like Computations, Executions can also take arguments.

## Choosing the Right Communication Mechanism

Each communication mechanism has its use case:

- **Broadcast Communication** (Signals/Effects): Use when multiple Transformers need to be notified of the same event, or when you don't know which Transformer should handle an event.
- **Data Access** (DataHolders): Use when you need to share state between Transformers.
- **Direct Communication** (Computations/Executions): Use when you need to directly invoke functionality in a specific Transformer.

## Communication Flow Example

Here's an example of how these mechanisms might be used together:

1. UI sends a Signal (`LoginSignal`) to the Router
2. AuthTransformer processes the Signal, performs authentication, and publishes an Effect (`AuthSuccessEffect`)
3. UserTransformer receives the Effect, fetches user data, and updates its DataHolder
4. ProfileTransformer accesses the user data via the DataHolder
5. NotificationTransformer computes the number of unread notifications via a Computation in the NotificationService Transformer
6. UI displays the profile information and notification count