{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Transmission","text":"<p>Transmission is an experimental asynchronous communication library for Kotlin Multiplatform projects, designed to create a structured communication network between different business logic components. It provides a clean, testable architecture that enables different parts of your application to communicate without direct references.</p>"},{"location":"#core-concepts","title":"Core Concepts","text":"<p>Transmission is built around three primary concepts:</p> <ul> <li>Transmission: The fundamental unit of information (Signal, Effect, Data)</li> <li>Transformer: Components that process transmissions and handle business logic</li> <li>TransmissionRouter: Manages the flow of transmissions between transformers</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Decoupled Communication: Components communicate without direct references</li> <li>Structured Flow: Clear information flow through Signal \u2192 Effect \u2192 Data channels</li> <li>Testable Architecture: Built with testing in mind for better business logic testing</li> <li>Asynchronous By Design: Built for asynchronous operations from the ground up</li> <li>Kotlin Multiplatform: Works across all Kotlin targets</li> </ul>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TB\n    UI[UI Layer] --&gt; |Signals| Router[TransmissionRouter]\n    Router --&gt; |Distributes| T1[Transformer 1]\n    Router --&gt; |Distributes| T2[Transformer 2] \n    Router --&gt; |Distributes| T3[Transformer 3]\n    T1 --&gt; |Effects| Router\n    T2 --&gt; |Effects| Router\n    T3 --&gt; |Effects| Router\n    T1 --&gt; |Data| Router\n    T2 --&gt; |Data| Router\n    T3 --&gt; |Data| Router\n    Router --&gt; |Data Stream| UI\n    T1 -.-&gt; |Query/Compute| T2\n    T2 -.-&gt; |Query/Compute| T3</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#1-define-transmissions","title":"1. Define Transmissions","text":"<pre><code>// Signals from UI\nsealed interface CounterSignal : Transmission.Signal {\n    data object Increment : CounterSignal\n    data object Decrement : CounterSignal\n}\n\n// Data for UI consumption  \ndata class CounterData(val count: Int) : Transmission.Data\n</code></pre>"},{"location":"#2-create-a-transformer","title":"2. Create a Transformer","text":"<pre><code>class CounterTransformer : Transformer() {\n    private var count = 0\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;CounterSignal.Increment&gt; {\n            count++\n            send(CounterData(count))\n        }\n\n        onSignal&lt;CounterSignal.Decrement&gt; {\n            count--\n            send(CounterData(count))\n        }\n    }\n}\n</code></pre>"},{"location":"#3-set-up-router","title":"3. Set up Router","text":"<pre><code>val router = TransmissionRouter {\n    addTransformerSet(setOf(CounterTransformer()))\n}\n</code></pre>"},{"location":"#4-use-in-ui","title":"4. Use in UI","text":"<pre><code>// Send signals\nrouter.process(CounterSignal.Increment)\n\n// Observe data\nrouter.streamData&lt;CounterData&gt;()\n    .collect { data -&gt;\n        // Update UI with data.count\n    }\n</code></pre>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>transmission/\n\u251c\u2500\u2500 transmission/           # Core library\n\u251c\u2500\u2500 transmission-test/      # Testing utilities  \n\u251c\u2500\u2500 samples/               # Example implementations\n\u2502   \u251c\u2500\u2500 counter/          # Simple counter example\n\u2502   \u2514\u2500\u2500 components/       # Complex multi-component example\n\u2514\u2500\u2500 docs/                 # Documentation\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Setup - Add Transmission to your project</li> <li>How to Use - Basic usage guide</li> <li>Transmissions - Understanding Signal, Effect, and Data</li> <li>Transformer - Creating business logic components</li> <li>TransmissionRouter - Managing communication flow</li> </ol>"},{"location":"#examples","title":"Examples","text":"<p>Check out the complete examples in the <code>samples</code> directory:</p> <ul> <li>Counter Sample: Simple increment/decrement counter demonstrating basic concepts</li> <li>Components Sample: Complex example with multiple transformers, effects, and inter-transformer communication</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to the Transmission library will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Comprehensive documentation with practical examples</li> <li>Complete API documentation for all core concepts</li> <li>Step-by-step setup guide for Kotlin Multiplatform projects</li> <li>Real-world examples using counter and components samples</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Updated setup documentation to reflect Maven Central publication from version 1.6.0+</li> <li>Improved testing documentation with correct TransmissionTest API</li> <li>Enhanced documentation structure and navigation</li> </ul>"},{"location":"changelog/#160-2025-05-16","title":"[1.6.0] - 2025-05-16","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Kotlin Multiplatform Support: Complete migration to Kotlin Multiplatform</li> <li>iOS target support with native compilation</li> <li>Desktop (JVM) target support</li> <li>Maven Central Publication: Now published to Maven Central instead of JitPack</li> <li>New publication workflow with signing and verification</li> <li>Convention plugins for build configuration management</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Breaking: Migrated from Android-only to Kotlin Multiplatform</li> <li>Breaking: Publication moved from JitPack to Maven Central</li> <li>Breaking: Dependency coordinates changed to <code>com.trendyol:transmission</code></li> <li>Refactored counter sample to Compose Multiplatform</li> <li>Updated build logic with new convention plugins</li> <li>Improved project structure for multiplatform development</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Legacy Android-only sample applications</li> <li>JitPack publication support for new versions</li> </ul>"},{"location":"changelog/#migration-guide","title":"Migration Guide","text":"<ul> <li>Update dependencies from <code>com.github.Trendyol:transmission</code> to <code>com.trendyol:transmission</code></li> <li>Remove JitPack repository if only using Transmission</li> <li>For KMP projects, configure targets as needed (android, iosX64, iosArm64, iosSimulatorArm64, jvmDesktop)</li> </ul>"},{"location":"changelog/#150-2025-03-24","title":"[1.5.0] - 2025-03-24","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>One-shot Payload Sending: New API for sending payloads without persistent subscriptions</li> <li>Enhanced transmission processing capabilities</li> <li>New experimental annotations for evolving APIs</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Improved payload handling performance</li> <li>Updated version numbering system</li> </ul>"},{"location":"changelog/#142-2025-03-14","title":"[1.4.2] - 2025-03-14","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Enhanced Testing Infrastructure: New <code>TransmissionTest</code> class replacing deprecated <code>TestSuite</code></li> <li>New test methods for checkpoint validation</li> <li>Improved test assertion methods with better type safety</li> <li>Additional transformer testing capabilities</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Breaking: Deprecated <code>TestSuite</code> in favor of <code>TransmissionTest</code></li> <li>Updated testing API with fluent builder pattern</li> <li>Improved test method naming and organization</li> <li>Enhanced sample test implementations</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Test indentation and formatting issues</li> <li>OutputTransformer test compatibility</li> <li>Broadcast functionality in testing scenarios</li> </ul>"},{"location":"changelog/#140-2025-02-25","title":"[1.4.0] - 2025-02-25","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Transformer Lifecycle: <code>onCleared()</code> callback for cleanup operations</li> <li>Handler Extension API: Ability to extend and override handler behavior</li> <li>Stacked Lambda System: Advanced handler composition capabilities</li> <li>Value Class Optimization: Converted <code>Capacity</code> to value class for better performance</li> <li>Stream Extensions: New extension functions for data and effect streaming</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Breaking: Refactored handler extension API</li> <li>Breaking: Updated <code>UpdateHandlerScope</code> implementation</li> <li>Improved router internals for better performance</li> <li>Enhanced API naming conventions for handlers</li> <li>Updated README with new features</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Removed redundant coroutine creation</li> <li>Fixed lambda versioning issues</li> <li>Improved memory management in handler chains</li> </ul>"},{"location":"changelog/#130-2024-11-14","title":"[1.3.0] - 2024-11-14","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Checkpoint API (Experimental): Advanced flow control with checkpoints</li> <li><code>@ExperimentalTransmissionApi</code> and <code>@InternalTransmissionApi</code> annotations</li> <li>CheckpointTracker for managing checkpoint state</li> <li>Checkpoint validation and frequency control</li> <li>Enhanced Contract system with checkpoint support</li> <li>Identity-based computation validation</li> <li>UUID-based identifier generation</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Breaking: Contract types converted to classes with internal constructors</li> <li>Breaking: Updated dataHolder API to remove manual key assignment</li> <li>Improved stability and thread safety</li> <li>Updated Kotlin to 2.0.20</li> <li>Enhanced Counter sample with better examples</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Removed buffer-related issues in broadcast system</li> <li>Improved mutex locking in dataHolder operations</li> <li>Fixed tryEmit/trySend calls replaced with suspending alternatives</li> </ul>"},{"location":"changelog/#121-previous-release","title":"[1.2.1] - Previous Release","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Core transmission framework</li> <li>Basic transformer functionality</li> <li>Router implementation</li> <li>Initial testing support</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>API stabilization improvements</li> <li>Performance optimizations</li> </ul>"},{"location":"changelog/#10x-series-legacy-releases","title":"[1.0.x Series] - Legacy Releases","text":"<p>Multiple releases focusing on: - Core functionality development - API refinements - Bug fixes and stability improvements - Initial testing framework</p>"},{"location":"changelog/#00x-series-early-development","title":"[0.0.x Series] - Early Development","text":"<p>Early development releases with: - Initial concept implementation - Proof of concept features - Experimental APIs</p>"},{"location":"changelog/#breaking-changes-summary","title":"Breaking Changes Summary","text":""},{"location":"changelog/#160","title":"1.6.0","text":"<ul> <li>Publication: Moved from JitPack to Maven Central</li> <li>Dependencies: Changed from <code>com.github.Trendyol:transmission</code> to <code>com.trendyol:transmission</code></li> <li>Platform: Migrated to Kotlin Multiplatform (supports Android, iOS, Desktop)</li> </ul>"},{"location":"changelog/#142","title":"1.4.2","text":"<ul> <li>Testing: <code>TestSuite</code> deprecated in favor of <code>TransmissionTest</code></li> </ul>"},{"location":"changelog/#140","title":"1.4.0","text":"<ul> <li>Handlers: Handler extension API redesigned</li> <li>Capacity: Converted to value class (source compatible)</li> </ul>"},{"location":"changelog/#130","title":"1.3.0","text":"<ul> <li>Contracts: Contract types changed from interfaces to classes</li> <li>DataHolder: Manual key assignment removed</li> </ul>"},{"location":"changelog/#experimental-features","title":"Experimental Features","text":"<p>Some features are marked as experimental and may evolve:</p> <ul> <li>Checkpoint System (<code>@ExperimentalTransmissionApi</code>): Advanced flow control</li> <li>Handler Extensions: Dynamic handler modification</li> <li>Advanced Transformer Communication: Complex inter-transformer patterns</li> </ul>"},{"location":"changelog/#migration-support","title":"Migration Support","text":"<p>For detailed migration guides between major versions, see: - Setup Guide for dependency updates - Testing Guide for test migration - Transformer Guide for API changes</p>"},{"location":"changelog/#contributing","title":"Contributing","text":"<p>We welcome contributions! See our GitHub repository for: - Bug reports and feature requests - Pull request guidelines - Development setup instructions</p> <p>This changelog reflects the actual development history. For the latest releases, check the GitHub releases page.</p>"},{"location":"contracts/","title":"Contracts","text":"<p>Contracts define interfaces for inter-transformer communication, providing type-safe ways for Transformers to interact with each other through computations, executions, data holders, and checkpoints.</p>"},{"location":"contracts/#overview","title":"Overview","text":"<p>Contracts enable Transformers to: - Query data from other Transformers (Computations) - Execute operations in other Transformers (Executions) - Access shared data holders (Data Holders) - Coordinate complex flows (Checkpoints)</p>"},{"location":"contracts/#types-of-contracts","title":"Types of Contracts","text":"<pre><code>sealed interface Contract {\n    class Identity\n    class DataHolder&lt;T : Transmission.Data?&gt;\n    class Computation&lt;T : Any?&gt;\n    class ComputationWithArgs&lt;A : Any, T : Any?&gt;\n    class Execution\n    class ExecutionWithArgs&lt;A : Any&gt;\n    class Checkpoint\n}\n</code></pre>"},{"location":"contracts/#identity-contracts","title":"Identity Contracts","text":"<p>Identity contracts provide unique identifiers for Transformers:</p> <pre><code>class MyTransformer : Transformer(\n    identity = Contract.identity()\n) {\n    // Transformer with unique identity\n}\n\n// Or use a shared identity\ncompanion object {\n    val transformerIdentity = Contract.identity()\n}\n\nclass MyTransformer : Transformer(identity = transformerIdentity)\n</code></pre>"},{"location":"contracts/#data-holder-contracts","title":"Data Holder Contracts","text":"<p>Data holder contracts enable shared state management:</p> <pre><code>class StateTransformer : Transformer() {\n\n    private val stateHolder = dataHolder(\n        initialValue = AppState(),\n        contract = appStateContract\n    )\n\n    companion object {\n        val appStateContract = Contract.dataHolder&lt;AppState&gt;()\n    }\n}\n\n// Other transformers can access this state through computations\nclass ConsumerTransformer : Transformer() {\n    override val computations: Computations = computations {\n        register(getCurrentStateContract) {\n            // Access the state holder from StateTransformer\n            // This requires additional implementation\n        }\n    }\n}\n</code></pre>"},{"location":"contracts/#computation-contracts","title":"Computation Contracts","text":"<p>Computations allow Transformers to query data from other Transformers:</p>"},{"location":"contracts/#simple-computations","title":"Simple Computations","text":"<pre><code>class DataProviderTransformer : Transformer() {\n    private var currentData = \"Initial Data\"\n\n    override val computations: Computations = computations {\n        register(getCurrentDataContract) {\n            currentData\n        }\n\n        register(getProcessedDataContract) {\n            processData(currentData)\n        }\n    }\n\n    companion object {\n        val getCurrentDataContract = Contract.computation&lt;String&gt;()\n        val getProcessedDataContract = Contract.computation&lt;ProcessedData&gt;()\n    }\n}\n\nclass ConsumerTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;RequestDataSignal&gt; {\n            // Query data from DataProviderTransformer\n            val data = compute(DataProviderTransformer.getCurrentDataContract)\n            val processedData = compute(DataProviderTransformer.getProcessedDataContract)\n\n            send(CombinedData(data, processedData))\n        }\n    }\n}\n</code></pre>"},{"location":"contracts/#computations-with-arguments","title":"Computations with Arguments","text":"<pre><code>class CalculatorTransformer : Transformer() {\n\n    override val computations: Computations = computations {\n        register(addNumbersContract) { numbers: List&lt;Int&gt; -&gt;\n            numbers.sum()\n        }\n\n        register(multiplyContract) { operands: MultiplyOperands -&gt;\n            operands.a * operands.b\n        }\n\n        register(formatNumberContract) { number: Double -&gt;\n            \"%.2f\".format(number)\n        }\n    }\n\n    companion object {\n        val addNumbersContract = Contract.computationWithArgs&lt;List&lt;Int&gt;, Int&gt;()\n        val multiplyContract = Contract.computationWithArgs&lt;MultiplyOperands, Int&gt;()\n        val formatNumberContract = Contract.computationWithArgs&lt;Double, String&gt;()\n    }\n}\n\ndata class MultiplyOperands(val a: Int, val b: Int)\n\nclass MathTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;CalculateSignal&gt; { signal -&gt;\n            // Use computations with arguments\n            val sum = compute(CalculatorTransformer.addNumbersContract, listOf(1, 2, 3, 4, 5))\n            val product = compute(CalculatorTransformer.multiplyContract, MultiplyOperands(6, 7))\n            val formatted = compute(CalculatorTransformer.formatNumberContract, 123.456)\n\n            send(CalculationResult(\"Sum: $sum, Product: $product, Formatted: $formatted\"))\n        }\n    }\n}\n</code></pre>"},{"location":"contracts/#cached-computations","title":"Cached Computations","text":"<pre><code>class ExpensiveCalculationTransformer : Transformer() {\n\n    override val computations: Computations = computations {\n        // Result is cached - expensive operation runs only once\n        register(expensiveOperationContract) {\n            performExpensiveCalculation()\n        }\n    }\n\n    companion object {\n        val expensiveOperationContract = Contract.computation&lt;BigDecimal&gt;(useCache = true)\n    }\n\n    private fun performExpensiveCalculation(): BigDecimal {\n        // Simulate expensive operation\n        Thread.sleep(5000)\n        return BigDecimal(\"123.456789\")\n    }\n}\n</code></pre>"},{"location":"contracts/#execution-contracts","title":"Execution Contracts","text":"<p>Executions are fire-and-forget operations for side effects:</p> <pre><code>class LoggingTransformer : Transformer() {\n\n    override val executions: Executions = executions {\n        register(logInfoContract) {\n            writeToLogFile(\"INFO\", \"General information logged\")\n        }\n\n        register(logWithMessageContract) { message: String -&gt;\n            writeToLogFile(\"INFO\", message)\n        }\n\n        register(logWithLevelContract) { logEntry: LogEntry -&gt;\n            writeToLogFile(logEntry.level, logEntry.message)\n        }\n    }\n\n    companion object {\n        val logInfoContract = Contract.execution()\n        val logWithMessageContract = Contract.executionWithArgs&lt;String&gt;()\n        val logWithLevelContract = Contract.executionWithArgs&lt;LogEntry&gt;()\n    }\n}\n\ndata class LogEntry(val level: String, val message: String)\n\nclass BusinessLogicTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;UserActionSignal&gt; { signal -&gt;\n            // Fire-and-forget logging\n            execute(LoggingTransformer.logInfoContract)\n            execute(LoggingTransformer.logWithMessageContract, \"User performed: ${signal.action}\")\n            execute(LoggingTransformer.logWithLevelContract, LogEntry(\"INFO\", \"Action completed\"))\n\n            // Continue with main business logic\n            send(ActionCompletedData(signal.action))\n        }\n    }\n}\n</code></pre>"},{"location":"contracts/#checkpoint-contracts-experimental","title":"Checkpoint Contracts (Experimental)","text":"<p>Checkpoints enable complex flow control and debugging:</p> <pre><code>@OptIn(ExperimentalTransmissionApi::class)\nclass FlowControlTransformer : Transformer() {\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;StartProcessSignal&gt; { signal -&gt;\n            // Pause execution until validation is complete\n            val validatedData = pauseOn(validationCheckpoint)\n\n            // Continue with validated data\n            send(ProcessCompletedData(validatedData))\n        }\n\n        onEffect&lt;ValidationCompleteEffect&gt; { effect -&gt;\n            // Resume paused execution with validated data\n            validate(validationCheckpoint, effect.validatedData)\n        }\n    }\n\n    companion object {\n        val validationCheckpoint = Contract.checkpointWithArgs&lt;ValidatedData&gt;()\n    }\n}\n</code></pre>"},{"location":"contracts/#examples-from-samples","title":"Examples from Samples","text":""},{"location":"contracts/#counter-sample","title":"Counter Sample","text":"<pre><code>// From samples/counter\nval lookUpAndReturn = Contract.computationWithArgs&lt;String, String&gt;()\n\nclass Worker(val id: String) : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;CounterSignal.Lookup&gt; {\n            // Use computation contract to get data from another transformer\n            send(CounterData(\"Transformer $id updated data to ${compute(lookUpAndReturn, id)}\"))\n        }\n    }\n}\n</code></pre>"},{"location":"contracts/#components-sample","title":"Components Sample","text":"<pre><code>// From samples/components/input/InputTransformer\n@OptIn(ExperimentalTransmissionApi::class)\nclass InputTransformer : Transformer() {\n\n    private val holder = dataHolder(InputUiState(), holderContract)\n\n    override val computations: Computations = computations {\n        register(writtenInputContract) {\n            delay(1.seconds)\n            WrittenInput(holder.getValue().writtenText)\n        }\n        register(writtenInputWithArgs) {\n            WrittenInput(it)\n        }\n    }\n\n    companion object {\n        val writtenInputWithArgs = Contract.computationWithArgs&lt;String, WrittenInput&gt;()\n        val writtenInputContract = Contract.computation&lt;WrittenInput&gt;()\n        val holderContract = Contract.dataHolder&lt;InputUiState&gt;()\n        val colorCheckpoint = Contract.checkpointWithArgs&lt;Color&gt;()\n    }\n}\n</code></pre>"},{"location":"contracts/#advanced-usage-patterns","title":"Advanced Usage Patterns","text":""},{"location":"contracts/#factory-pattern-for-contracts","title":"Factory Pattern for Contracts","text":"<pre><code>object ContractFactory {\n    fun &lt;T : Any&gt; createCachedComputation(): Contract.Computation&lt;T&gt; {\n        return Contract.computation(useCache = true)\n    }\n\n    fun &lt;A : Any, T : Any&gt; createParameterizedComputation(): Contract.ComputationWithArgs&lt;A, T&gt; {\n        return Contract.computationWithArgs(useCache = false)\n    }\n}\n\nclass MyTransformer : Transformer() {\n    companion object {\n        val cachedDataContract = ContractFactory.createCachedComputation&lt;ExpensiveData&gt;()\n        val parameterizedContract = ContractFactory.createParameterizedComputation&lt;String, ProcessedData&gt;()\n    }\n}\n</code></pre>"},{"location":"contracts/#contract-groups","title":"Contract Groups","text":"<pre><code>object UserContracts {\n    val getCurrentUser = Contract.computation&lt;User?&gt;()\n    val validateUser = Contract.computationWithArgs&lt;User, Boolean&gt;()\n    val saveUser = Contract.executionWithArgs&lt;User&gt;()\n    val deleteUser = Contract.executionWithArgs&lt;String&gt;()\n    val userDataHolder = Contract.dataHolder&lt;UserState&gt;()\n}\n\nobject AuthContracts {\n    val isAuthenticated = Contract.computation&lt;Boolean&gt;()\n    val authenticate = Contract.computationWithArgs&lt;Credentials, AuthResult&gt;()\n    val logout = Contract.execution()\n    val authStateHolder = Contract.dataHolder&lt;AuthState&gt;()\n}\n\nclass UserTransformer : Transformer() {\n    private val userHolder = dataHolder(UserState(), UserContracts.userDataHolder)\n\n    override val computations: Computations = computations {\n        register(UserContracts.getCurrentUser) {\n            userHolder.getValue().currentUser\n        }\n\n        register(UserContracts.validateUser) { user: User -&gt;\n            validateUserData(user)\n        }\n    }\n\n    override val executions: Executions = executions {\n        register(UserContracts.saveUser) { user: User -&gt;\n            saveUserToDatabase(user)\n        }\n\n        register(UserContracts.deleteUser) { userId: String -&gt;\n            deleteUserFromDatabase(userId)\n        }\n    }\n}\n</code></pre>"},{"location":"contracts/#conditional-contract-registration","title":"Conditional Contract Registration","text":"<pre><code>class ConfigurableTransformer(private val config: TransformerConfig) : Transformer() {\n\n    override val computations: Computations = computations {\n        // Always available\n        register(basicDataContract) {\n            getBasicData()\n        }\n\n        // Conditionally available based on configuration\n        if (config.enableAdvancedFeatures) {\n            register(advancedDataContract) {\n                getAdvancedData()\n            }\n        }\n\n        if (config.enableCaching) {\n            register(cachedDataContract) {\n                getCachedData()\n            }\n        }\n    }\n\n    companion object {\n        val basicDataContract = Contract.computation&lt;BasicData&gt;()\n        val advancedDataContract = Contract.computation&lt;AdvancedData&gt;()\n        val cachedDataContract = Contract.computation&lt;CachedData&gt;(useCache = true)\n    }\n}\n</code></pre>"},{"location":"contracts/#error-handling-with-contracts","title":"Error Handling with Contracts","text":""},{"location":"contracts/#safe-computation-calls","title":"Safe Computation Calls","text":"<pre><code>class SafeConsumerTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;RequestDataSignal&gt; {\n            try {\n                val data = compute(DataProviderTransformer.getCurrentDataContract)\n                send(DataRetrievedSuccessfully(data))\n            } catch (e: Exception) {\n                send(ErrorData(\"Failed to compute data: ${e.message}\"))\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"contracts/#nullable-return-types","title":"Nullable Return Types","text":"<pre><code>class OptionalDataTransformer : Transformer() {\n    override val computations: Computations = computations {\n        register(optionalDataContract) {\n            // May return null\n            getOptionalData()\n        }\n    }\n\n    companion object {\n        val optionalDataContract = Contract.computation&lt;OptionalData?&gt;()\n    }\n}\n\nclass ConsumerTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;CheckDataSignal&gt; {\n            val data = compute(OptionalDataTransformer.optionalDataContract)\n\n            if (data != null) {\n                send(DataAvailable(data))\n            } else {\n                send(NoDataAvailable)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"contracts/#testing-with-contracts","title":"Testing with Contracts","text":"<p>Contracts make testing easier by enabling mocking:</p> <pre><code>@Test\nfun `should handle data computation correctly`() = transmissionTest {\n    val providerTransformer = DataProviderTransformer()\n    val consumerTransformer = ConsumerTransformer()\n\n    // Test the computation\n    consumerTransformer.test {\n        send(RequestDataSignal)\n\n        expectData&lt;CombinedData&gt; { data -&gt;\n            assertNotNull(data.rawData)\n            assertNotNull(data.processedData)\n        }\n    }\n}\n</code></pre>"},{"location":"contracts/#best-practices","title":"Best Practices","text":""},{"location":"contracts/#1-organize-contracts-by-domain","title":"1. Organize Contracts by Domain","text":"<pre><code>// Good - domain-specific contract objects\nobject UserContracts {\n    val getCurrentUser = Contract.computation&lt;User?&gt;()\n    val validateCredentials = Contract.computationWithArgs&lt;Credentials, Boolean&gt;()\n}\n\nobject OrderContracts {\n    val getCurrentOrder = Contract.computation&lt;Order?&gt;()\n    val calculateTotal = Contract.computationWithArgs&lt;List&lt;OrderItem&gt;, BigDecimal&gt;()\n}\n\n// Avoid - mixed contracts\nobject AllContracts {\n    val userContract = Contract.computation&lt;User?&gt;()\n    val orderContract = Contract.computation&lt;Order?&gt;()\n    val paymentContract = Contract.computation&lt;Payment?&gt;()\n}\n</code></pre>"},{"location":"contracts/#2-use-descriptive-contract-names","title":"2. Use Descriptive Contract Names","text":"<pre><code>// Good - clear purpose\nval getCurrentUserDataContract = Contract.computation&lt;UserData&gt;()\nval validateUserInputContract = Contract.computationWithArgs&lt;UserInput, ValidationResult&gt;()\nval saveUserToDatabase = Contract.executionWithArgs&lt;User&gt;()\n\n// Avoid - vague names\nval userContract = Contract.computation&lt;UserData&gt;()\nval checkStuff = Contract.computationWithArgs&lt;Any, Boolean&gt;()\nval doThing = Contract.execution()\n</code></pre>"},{"location":"contracts/#3-group-related-contracts","title":"3. Group Related Contracts","text":"<pre><code>class AuthTransformer : Transformer() {\n    companion object {\n        // Authentication contracts\n        val isLoggedIn = Contract.computation&lt;Boolean&gt;()\n        val getCurrentUser = Contract.computation&lt;User?&gt;()\n        val authenticate = Contract.computationWithArgs&lt;Credentials, AuthResult&gt;()\n\n        // Session management contracts\n        val refreshToken = Contract.execution()\n        val invalidateSession = Contract.execution()\n\n        // State contracts\n        val authStateHolder = Contract.dataHolder&lt;AuthState&gt;()\n    }\n}\n</code></pre>"},{"location":"contracts/#4-use-type-safe-arguments","title":"4. Use Type-Safe Arguments","text":"<pre><code>// Good - specific types\ndata class SearchParams(val query: String, val filters: List&lt;Filter&gt;)\nval searchContract = Contract.computationWithArgs&lt;SearchParams, SearchResult&gt;()\n\n// Avoid - generic types\nval searchContract = Contract.computationWithArgs&lt;Map&lt;String, Any&gt;, Any&gt;()\n</code></pre>"},{"location":"contracts/#5-consider-caching-for-expensive-operations","title":"5. Consider Caching for Expensive Operations","text":"<pre><code>// For expensive computations\nval expensiveDataContract = Contract.computation&lt;ExpensiveData&gt;(useCache = true)\n\n// For frequently accessed data\nval frequentDataContract = Contract.computation&lt;FrequentData&gt;(useCache = true)\n\n// For simple, fast operations (default)\nval simpleDataContract = Contract.computation&lt;SimpleData&gt;()\n</code></pre>"},{"location":"dataholder/","title":"DataHolder","text":"<p>DataHolder is a state management component within Transformers that provides thread-safe, reactive state management with automatic data publishing capabilities.</p>"},{"location":"dataholder/#overview","title":"Overview","text":"<p>DataHolders allow Transformers to maintain internal state that can be: - Updated safely from multiple coroutines - Automatically published to the router's data stream - Queried by other Transformers through contracts - Tracked for debugging purposes</p>"},{"location":"dataholder/#basic-usage","title":"Basic Usage","text":""},{"location":"dataholder/#creating-a-dataholder","title":"Creating a DataHolder","text":"<pre><code>class UserTransformer : Transformer() {\n\n    // Create a data holder with initial state\n    private val userHolder = dataHolder(\n        initialValue = UserState(),\n        contract = userStateContract\n    )\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;UpdateUserSignal&gt; { signal -&gt;\n            // Update the state\n            userHolder.update { currentState -&gt;\n                currentState.copy(name = signal.newName)\n            }\n            // Updated state is automatically sent to data stream\n        }\n    }\n\n    companion object {\n        val userStateContract = Contract.dataHolder&lt;UserState&gt;()\n    }\n}\n</code></pre>"},{"location":"dataholder/#data-classes-for-state","title":"Data Classes for State","text":"<pre><code>data class UserState(\n    val user: User? = null,\n    val isLoading: Boolean = false,\n    val error: String? = null\n) : Transmission.Data\n\ndata class CounterState(\n    val count: Int = 0,\n    val step: Int = 1\n) : Transmission.Data\n\ndata class InputUiState(\n    val writtenText: String = \"\",\n    val backgroundColor: Color = Color.White\n) : Transmission.Data\n</code></pre>"},{"location":"dataholder/#dataholder-interface","title":"DataHolder Interface","text":"<pre><code>interface TransmissionDataHolder&lt;T : Transmission.Data?&gt; {\n    fun getValue(): T\n    fun update(updater: (T) -&gt; T)\n    suspend fun updateAndGet(updater: (T) -&gt; T): T\n}\n</code></pre>"},{"location":"dataholder/#methods","title":"Methods","text":"<ul> <li><code>getValue()</code>: Get the current state value</li> <li><code>update(updater)</code>: Update state synchronously  </li> <li><code>updateAndGet(updater)</code>: Update state and return the new value</li> </ul>"},{"location":"dataholder/#creation-options","title":"Creation Options","text":""},{"location":"dataholder/#basic-dataholder","title":"Basic DataHolder","text":"<pre><code>// Automatically publishes updates to data stream\nval holder = dataHolder(\n    initialValue = MyState(),\n    contract = myStateContract\n)\n</code></pre>"},{"location":"dataholder/#dataholder-without-auto-publishing","title":"DataHolder Without Auto-Publishing","text":"<pre><code>// Manual control over when to publish\nval holder = dataHolder(\n    initialValue = MyState(),\n    contract = myStateContract,\n    publishUpdates = false\n)\n</code></pre>"},{"location":"dataholder/#examples-from-samples","title":"Examples from Samples","text":""},{"location":"dataholder/#counter-sample","title":"Counter Sample","text":"<pre><code>// Simple data holding for counter state\ndata class CounterData(val id: String) : Transmission.Data\n\nclass Worker(val id: String) : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;CounterSignal.Lookup&gt; {\n            // Direct data sending without holder\n            send(CounterData(\"Transformer $id updated data to ${compute(lookUpAndReturn, id)}\"))\n        }\n    }\n}\n</code></pre>"},{"location":"dataholder/#components-sample-input-state","title":"Components Sample - Input State","text":"<pre><code>class InputTransformer(\n    private val defaultDispatcher: CoroutineDispatcher\n) : Transformer(dispatcher = defaultDispatcher) {\n\n    // DataHolder for input UI state\n    private val holder = dataHolder(InputUiState(), holderContract)\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;InputSignal.InputUpdate&gt; { signal -&gt;\n            // Update the holder state\n            holder.update { it.copy(writtenText = signal.value) }\n\n            // State is automatically published as InputUiState data\n        }\n\n        onEffect&lt;ColorPickerEffect.BackgroundColorUpdate&gt; { effect -&gt;\n            // Update background color\n            holder.update { it.copy(backgroundColor = effect.color) }\n        }\n    }\n\n    companion object {\n        val holderContract = Contract.dataHolder&lt;InputUiState&gt;()\n    }\n}\n</code></pre>"},{"location":"dataholder/#thread-safety","title":"Thread Safety","text":"<p>DataHolders are thread-safe and use internal locking:</p> <pre><code>class ConcurrentTransformer : Transformer() {\n    private val stateHolder = dataHolder(\n        initialValue = SharedState(),\n        contract = sharedStateContract\n    )\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;ConcurrentUpdateSignal&gt; { signal -&gt;\n            // Safe to call from multiple coroutines\n            stateHolder.update { state -&gt;\n                state.copy(counter = state.counter + 1)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"dataholder/#advanced-usage","title":"Advanced Usage","text":""},{"location":"dataholder/#conditional-updates","title":"Conditional Updates","text":"<pre><code>class ValidationTransformer : Transformer() {\n    private val validationHolder = dataHolder(\n        initialValue = ValidationState(),\n        contract = validationContract\n    )\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;ValidateInputSignal&gt; { signal -&gt;\n            val isValid = validateInput(signal.input)\n\n            // Only update if validation state changes\n            validationHolder.update { currentState -&gt;\n                if (currentState.isValid != isValid) {\n                    currentState.copy(\n                        isValid = isValid,\n                        lastValidated = System.currentTimeMillis()\n                    )\n                } else {\n                    currentState // No change\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"dataholder/#using-updateandget","title":"Using updateAndGet","text":"<pre><code>class StatefulTransformer : Transformer() {\n    private val counterHolder = dataHolder(\n        initialValue = CounterState(),\n        contract = counterContract\n    )\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;IncrementSignal&gt; { \n            // Get the new value after update\n            val newState = counterHolder.updateAndGet { state -&gt;\n                state.copy(count = state.count + 1)\n            }\n\n            // Use the new value for additional logic\n            if (newState.count % 10 == 0) {\n                publish(MilestoneReachedEffect(newState.count))\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"dataholder/#manual-publishing-control","title":"Manual Publishing Control","text":"<pre><code>class BatchTransformer : Transformer() {\n    private val batchHolder = dataHolder(\n        initialValue = BatchState(),\n        contract = batchContract,\n        publishUpdates = false // Manual publishing\n    )\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;AddToBatchSignal&gt; { signal -&gt;\n            batchHolder.update { state -&gt;\n                state.copy(items = state.items + signal.item)\n            }\n\n            // Don't publish until batch is complete\n        }\n\n        onSignal&lt;CompleteBatchSignal&gt; {\n            val finalState = batchHolder.getValue()\n\n            // Manually publish the final state\n            send(finalState)\n\n            // Reset for next batch\n            batchHolder.update { BatchState() }\n        }\n    }\n}\n</code></pre>"},{"location":"dataholder/#integration-with-computations","title":"Integration with Computations","text":"<p>DataHolders work seamlessly with computations for inter-transformer communication:</p> <pre><code>class DataProviderTransformer : Transformer() {\n    private val dataHolder = dataHolder(\n        initialValue = ProviderState(),\n        contract = providerContract\n    )\n\n    override val computations: Computations = computations {\n        // Other transformers can query current state\n        register(getCurrentDataContract) {\n            dataHolder.getValue()\n        }\n    }\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;UpdateDataSignal&gt; { signal -&gt;\n            dataHolder.update { state -&gt;\n                state.copy(data = signal.newData)\n            }\n        }\n    }\n}\n\nclass ConsumerTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;ProcessDataSignal&gt; {\n            // Query the provider's current state\n            val currentData = compute(getCurrentDataContract)\n\n            // Process the data\n            val result = processData(currentData)\n            send(ProcessedDataResult(result))\n        }\n    }\n}\n</code></pre>"},{"location":"dataholder/#error-handling","title":"Error Handling","text":"<p>Handle errors in state updates gracefully:</p> <pre><code>class SafeTransformer : Transformer() {\n    private val safeHolder = dataHolder(\n        initialValue = SafeState(),\n        contract = safeContract\n    )\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;RiskyUpdateSignal&gt; { signal -&gt;\n            try {\n                val validatedData = validateAndProcess(signal.data)\n\n                safeHolder.update { state -&gt;\n                    state.copy(\n                        data = validatedData,\n                        error = null\n                    )\n                }\n            } catch (e: Exception) {\n                safeHolder.update { state -&gt;\n                    state.copy(\n                        error = e.message,\n                        lastErrorTime = System.currentTimeMillis()\n                    )\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"dataholder/#complex-state-management","title":"Complex State Management","text":""},{"location":"dataholder/#nested-state-updates","title":"Nested State Updates","text":"<pre><code>data class ComplexState(\n    val user: UserInfo,\n    val preferences: UserPreferences,\n    val cache: Map&lt;String, Any&gt; = emptyMap()\n) : Transmission.Data\n\nclass ComplexTransformer : Transformer() {\n    private val complexHolder = dataHolder(\n        initialValue = ComplexState(\n            user = UserInfo(),\n            preferences = UserPreferences()\n        ),\n        contract = complexContract\n    )\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;UpdateUserInfoSignal&gt; { signal -&gt;\n            complexHolder.update { state -&gt;\n                state.copy(\n                    user = state.user.copy(\n                        name = signal.newName,\n                        email = signal.newEmail\n                    )\n                )\n            }\n        }\n\n        onSignal&lt;UpdatePreferenceSignal&gt; { signal -&gt;\n            complexHolder.update { state -&gt;\n                state.copy(\n                    preferences = state.preferences.copy(\n                        theme = signal.newTheme\n                    )\n                )\n            }\n        }\n\n        onSignal&lt;CacheDataSignal&gt; { signal -&gt;\n            complexHolder.update { state -&gt;\n                state.copy(\n                    cache = state.cache + (signal.key to signal.value)\n                )\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"dataholder/#best-practices","title":"Best Practices","text":""},{"location":"dataholder/#1-use-immutable-data-classes","title":"1. Use Immutable Data Classes","text":"<pre><code>// Good - immutable data class\ndata class UserState(\n    val user: User? = null,\n    val isLoading: Boolean = false\n) : Transmission.Data\n\n// Avoid - mutable properties\ndata class UserState(\n    var user: User? = null,\n    var isLoading: Boolean = false\n) : Transmission.Data\n</code></pre>"},{"location":"dataholder/#2-provide-default-values","title":"2. Provide Default Values","text":"<pre><code>// Good - sensible defaults\ndata class AppState(\n    val isInitialized: Boolean = false,\n    val currentUser: User? = null,\n    val settings: Settings = Settings.default()\n) : Transmission.Data\n</code></pre>"},{"location":"dataholder/#3-keep-state-focused","title":"3. Keep State Focused","text":"<pre><code>// Good - focused state\ndata class AuthState(\n    val isLoggedIn: Boolean = false,\n    val currentUser: User? = null\n) : Transmission.Data\n\n// Good - separate concerns\ndata class UIState(\n    val isLoading: Boolean = false,\n    val error: String? = null\n) : Transmission.Data\n\n// Avoid - mixed concerns\ndata class MixedState(\n    val isLoggedIn: Boolean = false,\n    val currentUser: User? = null,\n    val isLoading: Boolean = false,\n    val networkStatus: String = \"\",\n    val cacheData: Map&lt;String, Any&gt; = emptyMap()\n) : Transmission.Data\n</code></pre>"},{"location":"dataholder/#4-handle-null-states-carefully","title":"4. Handle Null States Carefully","text":"<pre><code>// Explicit nullable handling\ndata class OptionalDataState(\n    val data: ImportantData? = null,\n    val isLoading: Boolean = false,\n    val hasError: Boolean = false\n) : Transmission.Data\n\nclass DataTransformer : Transformer() {\n    private val dataHolder = dataHolder(\n        initialValue = OptionalDataState(),\n        contract = dataContract\n    )\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;LoadDataSignal&gt; {\n            dataHolder.update { it.copy(isLoading = true, hasError = false) }\n\n            try {\n                val data = loadData()\n                dataHolder.update { \n                    it.copy(\n                        data = data, \n                        isLoading = false, \n                        hasError = false\n                    ) \n                }\n            } catch (e: Exception) {\n                dataHolder.update { \n                    it.copy(\n                        isLoading = false, \n                        hasError = true\n                    ) \n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"handlers/","title":"Handlers","text":"<p>Handlers define how Transformers respond to incoming Signals and Effects. They contain the core business logic of your application and determine what happens when specific transmissions are received.</p>"},{"location":"handlers/#overview","title":"Overview","text":"<p>Handlers are defined within Transformers using the <code>handlers</code> DSL:</p> <pre><code>class MyTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;MySignal&gt; { signal -&gt;\n            // Handle signal\n        }\n\n        onEffect&lt;MyEffect&gt; { effect -&gt;\n            // Handle effect\n        }\n    }\n}\n</code></pre>"},{"location":"handlers/#signal-handlers","title":"Signal Handlers","text":"<p>Signal handlers respond to incoming Signals from the UI or external sources.</p>"},{"location":"handlers/#basic-signal-handler","title":"Basic Signal Handler","text":"<pre><code>override val handlers: Handlers = handlers {\n    onSignal&lt;UserLoginSignal&gt; { signal -&gt;\n        // Access signal properties\n        val credentials = signal.credentials\n\n        // Perform business logic\n        val result = authenticateUser(credentials)\n\n        // Send data or publish effects\n        if (result.isSuccess) {\n            send(UserData(result.user))\n            publish(NavigationEffect.GoToHome)\n        } else {\n            send(ErrorData(\"Login failed\"))\n        }\n    }\n}\n</code></pre>"},{"location":"handlers/#multiple-signal-handlers","title":"Multiple Signal Handlers","text":"<pre><code>override val handlers: Handlers = handlers {\n    onSignal&lt;IncrementSignal&gt; {\n        count++\n        send(CounterData(count))\n    }\n\n    onSignal&lt;DecrementSignal&gt; {\n        count--  \n        send(CounterData(count))\n    }\n\n    onSignal&lt;ResetSignal&gt; {\n        count = 0\n        send(CounterData(count))\n    }\n}\n</code></pre>"},{"location":"handlers/#effect-handlers","title":"Effect Handlers","text":"<p>Effect handlers respond to Effects, which can come from other Transformers or the same Transformer.</p>"},{"location":"handlers/#basic-effect-handler","title":"Basic Effect Handler","text":"<pre><code>override val handlers: Handlers = handlers {\n    onEffect&lt;RefreshDataEffect&gt; { effect -&gt;\n        // Handle refresh request\n        val freshData = fetchDataFromServer()\n        send(FreshDataLoaded(freshData))\n    }\n\n    onEffect&lt;LoggingEffect&gt; { effect -&gt;\n        // Handle logging\n        logger.log(effect.level, effect.message)\n    }\n}\n</code></pre>"},{"location":"handlers/#chaining-effects","title":"Chaining Effects","text":"<pre><code>override val handlers: Handlers = handlers {\n    onSignal&lt;ProcessDataSignal&gt; { signal -&gt;\n        // Start processing chain\n        publish(ValidateDataEffect(signal.data))\n    }\n\n    onEffect&lt;ValidateDataEffect&gt; { effect -&gt;\n        val isValid = validateData(effect.data)\n        if (isValid) {\n            publish(SaveDataEffect(effect.data))\n        } else {\n            send(ValidationErrorData(\"Invalid data\"))\n        }\n    }\n\n    onEffect&lt;SaveDataEffect&gt; { effect -&gt;\n        saveData(effect.data)\n        send(DataSavedSuccessfully(effect.data))\n    }\n}\n</code></pre>"},{"location":"handlers/#communication-scope","title":"Communication Scope","text":"<p>Within handlers, you have access to <code>CommunicationScope</code> which provides several operations:</p>"},{"location":"handlers/#sending-data","title":"Sending Data","text":"<p>Data is sent to the router's data stream for UI consumption:</p> <pre><code>onSignal&lt;LoadUserSignal&gt; { signal -&gt;\n    val user = loadUser(signal.userId)\n    send(UserData(user)) // Available to UI via router.streamData()\n}\n</code></pre>"},{"location":"handlers/#publishing-effects","title":"Publishing Effects","text":"<p>Effects are published to other Transformers:</p> <pre><code>onSignal&lt;UserActionSignal&gt; { signal -&gt;\n    // Publish to any transformer listening for this effect\n    publish(LoggingEffect(\"User performed: ${signal.action}\"))\n\n    // Publish to specific transformer\n    publish(\n        effect = NotificationEffect(\"Action completed\"),\n        identity = notificationTransformerIdentity\n    )\n}\n</code></pre>"},{"location":"handlers/#inter-transformer-communication","title":"Inter-Transformer Communication","text":""},{"location":"handlers/#computing-values","title":"Computing Values","text":"<pre><code>onSignal&lt;CalculateSignal&gt; { signal -&gt;\n    // Get value from another transformer\n    val currentData = compute(dataContract)\n\n    // Compute with arguments\n    val result = compute(calculationContract, signal.input)\n\n    send(CalculationResult(result))\n}\n</code></pre>"},{"location":"handlers/#executing-operations","title":"Executing Operations","text":"<pre><code>onSignal&lt;UserActionSignal&gt; { signal -&gt;\n    // Fire-and-forget operation\n    execute(logActionContract)\n\n    // Execute with arguments\n    execute(auditContract, AuditEntry(signal.action, System.currentTimeMillis()))\n\n    send(ActionCompletedData())\n}\n</code></pre>"},{"location":"handlers/#complete-examples","title":"Complete Examples","text":""},{"location":"handlers/#counter-sample-handler","title":"Counter Sample Handler","text":"<pre><code>class Worker(val id: String) : Transformer() {\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;CounterSignal.Lookup&gt; {\n            // Compute value from another transformer and send data\n            send(CounterData(\"Transformer $id updated data to ${compute(lookUpAndReturn, id)}\"))\n        }\n    }\n}\n</code></pre>"},{"location":"handlers/#input-transformer-from-components-sample","title":"Input Transformer from Components Sample","text":"<pre><code>class InputTransformer(\n    private val defaultDispatcher: CoroutineDispatcher\n) : Transformer(dispatcher = defaultDispatcher) {\n\n    private val holder = dataHolder(InputUiState(), holderContract)\n\n    @OptIn(ExperimentalTransmissionApi::class)\n    override val handlers: Handlers = handlers {\n        onSignal&lt;InputSignal.InputUpdate&gt; { signal -&gt;\n            // Update local state\n            holder.update { it.copy(writtenText = signal.value) }\n\n            // Checkpoint-based communication (experimental)\n            val color = pauseOn(colorCheckpoint)\n\n            // Send effect to specific transformer\n            send(\n                effect = ColorPickerEffect.SelectedColorUpdate(color),\n                identity = multiOutputTransformerIdentity\n            )\n\n            // Publish effect to all listeners\n            publish(effect = InputEffect.InputUpdate(signal.value))\n        }\n\n        onEffect&lt;ColorPickerEffect.BackgroundColorUpdate&gt; { effect -&gt;\n            // Validate checkpoint\n            validate(colorCheckpoint, effect.color)\n\n            // Update state based on effect\n            holder.update { it.copy(backgroundColor = effect.color) }\n        }\n    }\n}\n</code></pre>"},{"location":"handlers/#complex-business-logic-handler","title":"Complex Business Logic Handler","text":"<pre><code>class OrderTransformer : Transformer() {\n    private val orderHolder = dataHolder(OrderState(), orderContract)\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;CreateOrderSignal&gt; { signal -&gt;\n            // Start order creation process\n            orderHolder.update { it.copy(isProcessing = true) }\n\n            // Validate order\n            publish(ValidateOrderEffect(signal.orderDetails))\n        }\n\n        onEffect&lt;ValidateOrderEffect&gt; { effect -&gt;\n            try {\n                val validationResult = validateOrder(effect.orderDetails)\n\n                if (validationResult.isValid) {\n                    publish(ProcessPaymentEffect(effect.orderDetails))\n                } else {\n                    orderHolder.update { \n                        it.copy(\n                            isProcessing = false,\n                            error = validationResult.errorMessage\n                        )\n                    }\n                }\n            } catch (e: Exception) {\n                orderHolder.update { \n                    it.copy(\n                        isProcessing = false,\n                        error = \"Validation failed: ${e.message}\"\n                    )\n                }\n            }\n        }\n\n        onEffect&lt;ProcessPaymentEffect&gt; { effect -&gt;\n            try {\n                val paymentResult = processPayment(effect.orderDetails.payment)\n\n                if (paymentResult.isSuccess) {\n                    publish(CreateOrderRecordEffect(effect.orderDetails, paymentResult.transactionId))\n                } else {\n                    orderHolder.update { \n                        it.copy(\n                            isProcessing = false,\n                            error = \"Payment failed: ${paymentResult.error}\"\n                        )\n                    }\n                }\n            } catch (e: Exception) {\n                orderHolder.update { \n                    it.copy(\n                        isProcessing = false,\n                        error = \"Payment processing error: ${e.message}\"\n                    )\n                }\n            }\n        }\n\n        onEffect&lt;CreateOrderRecordEffect&gt; { effect -&gt;\n            try {\n                val order = createOrderRecord(effect.orderDetails, effect.transactionId)\n\n                orderHolder.update { \n                    it.copy(\n                        isProcessing = false,\n                        completedOrder = order,\n                        error = null\n                    )\n                }\n\n                // Notify other systems\n                publish(OrderCreatedEffect(order))\n                execute(sendConfirmationEmailContract, order.customerEmail)\n\n            } catch (e: Exception) {\n                orderHolder.update { \n                    it.copy(\n                        isProcessing = false,\n                        error = \"Order creation failed: ${e.message}\"\n                    )\n                }\n            }\n        }\n\n        onEffect&lt;OrderCreatedEffect&gt; { effect -&gt;\n            // Update analytics\n            execute(trackOrderContract, AnalyticsEvent.OrderCreated(effect.order.id))\n        }\n    }\n}\n</code></pre>"},{"location":"handlers/#error-handling-in-handlers","title":"Error Handling in Handlers","text":""},{"location":"handlers/#try-catch-in-handlers","title":"Try-Catch in Handlers","text":"<pre><code>override val handlers: Handlers = handlers {\n    onSignal&lt;RiskyOperationSignal&gt; { signal -&gt;\n        try {\n            val result = performRiskyOperation(signal.data)\n            send(OperationSuccessData(result))\n        } catch (e: NetworkException) {\n            send(NetworkErrorData(\"Network error: ${e.message}\"))\n        } catch (e: ValidationException) {\n            send(ValidationErrorData(\"Invalid input: ${e.message}\"))\n        } catch (e: Exception) {\n            send(GenericErrorData(\"Unexpected error: ${e.message}\"))\n        }\n    }\n}\n</code></pre>"},{"location":"handlers/#using-result-types","title":"Using Result Types","text":"<pre><code>override val handlers: Handlers = handlers {\n    onSignal&lt;LoadDataSignal&gt; { signal -&gt;\n        when (val result = loadDataSafely(signal.id)) {\n            is Result.Success -&gt; {\n                send(DataLoadedSuccessfully(result.data))\n            }\n            is Result.Failure -&gt; {\n                send(DataLoadingFailed(result.error))\n                publish(LoggingEffect(\"Data loading failed: ${result.error}\"))\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"handlers/#advanced-handler-patterns","title":"Advanced Handler Patterns","text":""},{"location":"handlers/#state-machine-pattern","title":"State Machine Pattern","text":"<pre><code>class StateMachineTransformer : Transformer() {\n    private val stateHolder = dataHolder(MachineState.Idle, stateContract)\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;StartProcessSignal&gt; { signal -&gt;\n            val currentState = stateHolder.getValue()\n\n            when (currentState) {\n                is MachineState.Idle -&gt; {\n                    stateHolder.update { MachineState.Processing(signal.data) }\n                    publish(BeginProcessingEffect(signal.data))\n                }\n                is MachineState.Processing -&gt; {\n                    send(ErrorData(\"Process already running\"))\n                }\n                is MachineState.Completed -&gt; {\n                    stateHolder.update { MachineState.Processing(signal.data) }\n                    publish(BeginProcessingEffect(signal.data))\n                }\n            }\n        }\n\n        onEffect&lt;ProcessCompletedEffect&gt; { effect -&gt;\n            stateHolder.update { MachineState.Completed(effect.result) }\n        }\n    }\n}\n\nsealed class MachineState : Transmission.Data {\n    object Idle : MachineState()\n    data class Processing(val data: Any) : MachineState()\n    data class Completed(val result: Any) : MachineState()\n}\n</code></pre>"},{"location":"handlers/#command-pattern","title":"Command Pattern","text":"<pre><code>class CommandTransformer : Transformer() {\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;ExecuteCommandSignal&gt; { signal -&gt;\n            when (val command = signal.command) {\n                is Command.Save -&gt; handleSaveCommand(command)\n                is Command.Load -&gt; handleLoadCommand(command)\n                is Command.Delete -&gt; handleDeleteCommand(command)\n            }\n        }\n    }\n\n    private suspend fun CommunicationScope.handleSaveCommand(command: Command.Save) {\n        // Save logic\n        saveData(command.data)\n        send(CommandExecutedData(\"Save completed\"))\n    }\n\n    private suspend fun CommunicationScope.handleLoadCommand(command: Command.Load) {\n        // Load logic\n        val data = loadData(command.id)\n        send(DataLoadedData(data))\n    }\n\n    private suspend fun CommunicationScope.handleDeleteCommand(command: Command.Delete) {\n        // Delete logic\n        deleteData(command.id)\n        send(CommandExecutedData(\"Delete completed\"))\n    }\n}\n\nsealed class Command {\n    data class Save(val data: Any) : Command()\n    data class Load(val id: String) : Command()\n    data class Delete(val id: String) : Command()\n}\n</code></pre>"},{"location":"handlers/#observer-pattern","title":"Observer Pattern","text":"<pre><code>class ObserverTransformer : Transformer() {\n    private val observersHolder = dataHolder(\n        initialValue = ObserverState(),\n        contract = observerContract\n    )\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;RegisterObserverSignal&gt; { signal -&gt;\n            observersHolder.update { state -&gt;\n                state.copy(observers = state.observers + signal.observer)\n            }\n        }\n\n        onSignal&lt;NotifyObserversSignal&gt; { signal -&gt;\n            val observers = observersHolder.getValue().observers\n\n            observers.forEach { observer -&gt;\n                publish(NotifyObserverEffect(observer, signal.event))\n            }\n        }\n\n        onEffect&lt;NotifyObserverEffect&gt; { effect -&gt;\n            // Notify specific observer\n            notifyObserver(effect.observer, effect.event)\n        }\n    }\n}\n</code></pre>"},{"location":"handlers/#testing-handlers","title":"Testing Handlers","text":"<p>Handlers are easily testable using the transmission-test module:</p> <pre><code>@Test\nfun `should handle login signal correctly`() = transmissionTest {\n    val transformer = AuthTransformer()\n\n    // Send signal\n    transformer.test {\n        send(UserLoginSignal(validCredentials))\n\n        // Verify data output\n        expectData&lt;UserData&gt; { userData -&gt;\n            assertEquals(\"John Doe\", userData.user.name)\n        }\n\n        // Verify effect output  \n        expectEffect&lt;NavigationEffect.GoToHome&gt;()\n    }\n}\n</code></pre>"},{"location":"handlers/#best-practices","title":"Best Practices","text":""},{"location":"handlers/#1-keep-handlers-focused","title":"1. Keep Handlers Focused","text":"<pre><code>// Good - single responsibility\nonSignal&lt;ValidateInputSignal&gt; { signal -&gt;\n    val isValid = validateInput(signal.input)\n    send(ValidationResult(isValid))\n}\n\n// Avoid - multiple responsibilities\nonSignal&lt;ProcessEverythingSignal&gt; { signal -&gt;\n    validateInput(signal.input)\n    saveToDatabase(signal.data)\n    sendEmail(signal.email)\n    updateUI(signal.uiData)\n    logAction(signal.action)\n}\n</code></pre>"},{"location":"handlers/#2-use-descriptive-signaleffect-names","title":"2. Use Descriptive Signal/Effect Names","text":"<pre><code>// Good - clear intent\nonSignal&lt;UserRequestsPasswordResetSignal&gt; { /* ... */ }\nonEffect&lt;PasswordResetEmailSentEffect&gt; { /* ... */ }\n\n// Avoid - vague names\nonSignal&lt;UserSignal&gt; { /* ... */ }\nonEffect&lt;SomeEffect&gt; { /* ... */ }\n</code></pre>"},{"location":"handlers/#3-handle-errors-gracefully","title":"3. Handle Errors Gracefully","text":"<pre><code>onSignal&lt;LoadDataSignal&gt; { signal -&gt;\n    try {\n        val data = loadData(signal.id)\n        send(DataLoadedSuccessfully(data))\n    } catch (e: Exception) {\n        send(ErrorData(\"Failed to load data: ${e.message}\"))\n        execute(logErrorContract, e)\n    }\n}\n</code></pre>"},{"location":"handlers/#4-use-immutable-operations","title":"4. Use Immutable Operations","text":"<pre><code>// Good - immutable updates\nonSignal&lt;UpdateUserSignal&gt; { signal -&gt;\n    userHolder.update { currentUser -&gt;\n        currentUser.copy(name = signal.newName)\n    }\n}\n\n// Avoid - mutable operations\nonSignal&lt;UpdateUserSignal&gt; { signal -&gt;\n    val user = userHolder.getValue()\n    user.name = signal.newName // Mutation!\n    userHolder.update { user }\n}\n</code></pre>"},{"location":"handlers/#5-chain-related-operations","title":"5. Chain Related Operations","text":"<pre><code>// Good - clear flow\nonSignal&lt;CreateAccountSignal&gt; { signal -&gt;\n    publish(ValidateAccountDataEffect(signal.accountData))\n}\n\nonEffect&lt;ValidateAccountDataEffect&gt; { effect -&gt;\n    if (isValid(effect.accountData)) {\n        publish(CreateAccountRecordEffect(effect.accountData))\n    } else {\n        send(ValidationErrorData(\"Invalid account data\"))\n    }\n}\n\nonEffect&lt;CreateAccountRecordEffect&gt; { effect -&gt;\n    val account = createAccount(effect.accountData)\n    send(AccountCreatedData(account))\n    publish(SendWelcomeEmailEffect(account.email))\n}\n</code></pre>"},{"location":"how_to_use/","title":"How To Use","text":"<p>This guide provides a quick overview of how to use the Transmission library in your Kotlin Multiplatform project.</p>"},{"location":"how_to_use/#basic-usage-flow","title":"Basic Usage Flow","text":"<ol> <li>Define your Transmissions (Signals, Effects, Data)</li> <li>Create Transformers to process these transmissions</li> <li>Set up a TransmissionRouter to coordinate communication</li> <li>Connect your UI to the Transmission network</li> </ol>"},{"location":"how_to_use/#1-define-your-transmissions","title":"1. Define Your Transmissions","text":"<p>First, define the different types of transmissions your application will use:</p> <pre><code>// Signal - Input from UI or external events\nobject IncrementCounterSignal : Transmission.Signal\ndata class UpdateTextSignal(val text: String) : Transmission.Signal\n\n// Effect - Intermediate processing\ndata class LoggingEffect(val message: String) : Transmission.Effect\nobject RefreshUIEffect : Transmission.Effect\n\n// Data - Output for consumption\ndata class CounterData(val count: Int) : Transmission.Data\ndata class TextData(val text: String) : Transmission.Data\n</code></pre>"},{"location":"how_to_use/#2-create-transformers","title":"2. Create Transformers","text":"<p>Create Transformers to process your transmissions:</p> <pre><code>class CounterTransformer : Transformer() {\n    private var count = 0\n    private val counterDataHolder = dataHolder(\n        initialValue = CounterData(0),\n        contract = counterDataContract\n    )\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;IncrementCounterSignal&gt; {\n            count++\n            publish(LoggingEffect(\"Counter incremented to $count\"))\n            counterDataHolder.update { CounterData(count) }\n        }\n\n        onEffect&lt;RefreshUIEffect&gt; {\n            counterDataHolder.update { CounterData(count) }\n        }\n    }\n\n    companion object {\n        val counterDataContract = Contract.dataHolder&lt;CounterData&gt;()\n    }\n}\n\nclass TextTransformer : Transformer() {\n    private val textDataHolder = dataHolder(\n        initialValue = TextData(\"\"),\n        contract = textDataContract\n    )\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;UpdateTextSignal&gt; { signal -&gt;\n            textDataHolder.update { TextData(signal.text) }\n            publish(LoggingEffect(\"Text updated to ${signal.text}\"))\n        }\n    }\n\n    companion object {\n        val textDataContract = Contract.dataHolder&lt;TextData&gt;()\n    }\n}\n\nclass LoggingTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onEffect&lt;LoggingEffect&gt; { effect -&gt;\n            println(\"Log: ${effect.message}\")\n        }\n    }\n}\n</code></pre>"},{"location":"how_to_use/#3-set-up-transmissionrouter","title":"3. Set Up TransmissionRouter","text":"<p>Set up a TransmissionRouter to coordinate communication between your Transformers:</p> <pre><code>val router = TransmissionRouter {\n    addTransformerSet(setOf(\n        CounterTransformer(),\n        TextTransformer(),\n        LoggingTransformer()\n    ))\n}\n</code></pre>"},{"location":"how_to_use/#4-connect-your-ui","title":"4. Connect Your UI","text":""},{"location":"how_to_use/#option-a-direct-router-usage","title":"Option A: Direct Router Usage","text":"<p>Connect your UI directly to the Transmission network:</p> <pre><code>// Handle UI events\nincrementButton.setOnClickListener {\n    router.process(IncrementCounterSignal)\n}\n\ntextInput.addTextChangedListener {\n    router.process(UpdateTextSignal(it.toString()))\n}\n\n// Observe data changes\nlifecycleScope.launch {\n    router.streamData&lt;CounterData&gt;()\n        .collect { data -&gt;\n            countTextView.text = \"Count: ${data.count}\"\n        }\n}\n\nlifecycleScope.launch {\n    router.streamData&lt;TextData&gt;()\n        .collect { data -&gt;\n            outputTextView.text = data.text\n        }\n}\n</code></pre>"},{"location":"how_to_use/#option-b-routerviewmodel-multiplatform","title":"Option B: RouterViewModel (Multiplatform)","text":"<p>For multiplatform applications, use RouterViewModel for cleaner architecture across all platforms:</p> <pre><code>class MainViewModel : RouterViewModel(\n    setOf(\n        CounterTransformer(),\n        TextTransformer(),\n        LoggingTransformer()\n    )\n) {\n    // StateFlow properties for UI\n    val counterState = streamDataAsState&lt;CounterData&gt;(CounterData(0))\n    val textState = streamDataAsState&lt;TextData&gt;(TextData(\"\"))\n\n    // Handle effects\n    override fun onEffect(effect: Transmission.Effect) {\n        when (effect) {\n            is LoggingEffect -&gt; Log.d(\"MainViewModel\", effect.message)\n        }\n    }\n\n    // Public methods for UI interaction\n    fun incrementCounter() {\n        processSignal(IncrementCounterSignal)\n    }\n\n    fun updateText(text: String) {\n        processSignal(UpdateTextSignal(text))\n    }\n\n    fun refreshUI() {\n        processEffect(RefreshUIEffect)\n    }\n}\n\n// In your Compose UI\n@Composable\nfun MainScreen(viewModel: MainViewModel = viewModel()) {\n    val counterState by viewModel.counterState.collectAsState()\n    val textState by viewModel.textState.collectAsState()\n\n    Column {\n        Text(\"Count: ${counterState.count}\")\n        Button(onClick = { viewModel.incrementCounter() }) {\n            Text(\"Increment\")\n        }\n\n        TextField(\n            value = textState.text,\n            onValueChange = { viewModel.updateText(it) }\n        )\n\n        Button(onClick = { viewModel.refreshUI() }) {\n            Text(\"Refresh\")\n        }\n    }\n}\n</code></pre>"},{"location":"how_to_use/#5-advanced-communication","title":"5. Advanced Communication","text":"<p>For more complex scenarios, use Contracts for inter-Transformer communication:</p> <pre><code>// Define a contract\nval counterValueContract = Contract.computation&lt;Int&gt;()\n\n// In CounterTransformer\noverride val computations: Computations = computations {\n    register(counterValueContract) {\n        count\n    }\n}\n\n// In AnotherTransformer\noverride val handlers: Handlers = handlers {\n    onSignal&lt;SomeSignal&gt; {\n        val currentCount = compute(counterValueContract)\n        // Use the count\n        send(SomeData(currentCount))\n    }\n}\n</code></pre>"},{"location":"how_to_use/#complete-example","title":"Complete Example","text":"<p>For complete examples, check out the sample modules in the repository:</p> <ul> <li>Counter Sample: Simple increment/decrement counter demonstrating basic concepts</li> <li>Components Sample: Complex example with multiple transformers and inter-transformer communication</li> </ul> <p>The samples demonstrate practical use cases for the Transmission library in real Kotlin Multiplatform applications.</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>This roadmap outlines the planned development direction for the Transmission library. Please note that priorities and timelines may change based on community feedback and project needs.</p>"},{"location":"roadmap/#current-status","title":"Current Status","text":"<p>\u2705 Core Library (v0.1.0) - Basic transmission types (Signal, Effect, Data) - Transformer implementation with handlers - TransmissionRouter for communication management - DataHolder for state management - Contract system for inter-transformer communication - Testing framework and utilities - Comprehensive documentation</p>"},{"location":"roadmap/#upcoming-releases","title":"Upcoming Releases","text":""},{"location":"roadmap/#v020-enhanced-developer-experience-q2-2024","title":"v0.2.0 - Enhanced Developer Experience (Q2 2024)","text":""},{"location":"roadmap/#focus-tooling-and-developer-productivity","title":"\ud83c\udfaf Focus: Tooling and Developer Productivity","text":"<p>New Features: - Debugging Tools   - Transmission flow visualization   - Router state inspection utilities   - Performance monitoring hooks   - Development-time flow validation</p> <ul> <li>IDE Integration</li> <li>IntelliJ/Android Studio plugin for transmission flow visualization</li> <li>Code generation templates for common patterns</li> <li> <p>Live templates for transformers and contracts</p> </li> <li> <p>Enhanced Testing</p> </li> <li>Time-travel debugging for transformers</li> <li>Mock transformer generation utilities</li> <li>Integration test helpers for multi-transformer scenarios</li> <li>Performance testing utilities</li> </ul> <p>Improvements: - Better error messages with stack trace correlation - Improved documentation with interactive examples - Performance optimizations for high-throughput scenarios</p>"},{"location":"roadmap/#v030-advanced-communication-patterns-q3-2024","title":"v0.3.0 - Advanced Communication Patterns (Q3 2024)","text":""},{"location":"roadmap/#focus-complex-business-logic-support","title":"\ud83c\udfaf Focus: Complex Business Logic Support","text":"<p>New Features: - Saga Pattern Support   - Long-running transaction management   - Compensation action handling   - State persistence for saga steps</p> <ul> <li>Distributed Communication</li> <li>Multi-router communication</li> <li>Router federation for microservice architectures</li> <li> <p>Event sourcing integration</p> </li> <li> <p>Advanced Checkpoints</p> </li> <li>Checkpoint persistence</li> <li>Complex flow orchestration</li> <li>Conditional checkpoint validation</li> </ul> <p>Improvements: - Enhanced contract system with versioning - Better memory management for long-running transformers - Improved error recovery mechanisms</p>"},{"location":"roadmap/#v100-stable-api-q4-2024","title":"v1.0.0 - Stable API (Q4 2024)","text":""},{"location":"roadmap/#focus-production-readiness-and-stability","title":"\ud83c\udfaf Focus: Production Readiness and Stability","text":"<p>Stabilization: - API freeze with backward compatibility guarantees - Comprehensive migration guides from experimental features - Production-ready performance characteristics - Enterprise-grade security considerations</p> <p>Final Features: - Complete tooling ecosystem - Advanced monitoring and observability - Integration with popular frameworks - Comprehensive example applications</p>"},{"location":"roadmap/#long-term-vision-2025","title":"Long-term Vision (2025+)","text":""},{"location":"roadmap/#v110-ecosystem-expansion","title":"v1.1.0+ - Ecosystem Expansion","text":"<p>Platform Support: - Web Support   - JavaScript/WASM compilation targets   - Browser-specific optimizations   - Integration with web frameworks</p> <ul> <li>Native Enhancements</li> <li>Platform-specific optimizations</li> <li>Native UI framework integrations</li> <li>Background processing capabilities</li> </ul> <p>Framework Integrations: - Android   - Jetpack Compose integration   - WorkManager integration   - Room database integration</p> <ul> <li>iOS</li> <li>SwiftUI bridge utilities</li> <li>Core Data integration</li> <li> <p>Background app refresh support</p> </li> <li> <p>Desktop</p> </li> <li>Compose Desktop optimizations</li> <li>Native file system integration</li> </ul>"},{"location":"roadmap/#v200-next-generation-architecture","title":"v2.0.0 - Next Generation Architecture","text":"<p>Revolutionary Features: - AI-Powered Development   - Automatic transformer generation from business requirements   - Intelligent flow optimization suggestions   - Automated testing scenario generation</p> <ul> <li>Code Generation</li> <li>Compile-time transformer validation</li> <li>Automatic contract generation from interfaces</li> <li> <p>Type-safe configuration DSL</p> </li> <li> <p>Advanced Runtime</p> </li> <li>Hot-swappable transformers in development</li> <li>Runtime transformer composition</li> <li>Dynamic flow reconfiguration</li> </ul>"},{"location":"roadmap/#community-contributions","title":"Community Contributions","text":"<p>We actively encourage community contributions in the following areas:</p>"},{"location":"roadmap/#high-priority-needs","title":"High Priority Needs","text":"<p>Documentation: - Additional real-world examples - Platform-specific guides - Performance optimization tutorials - Architecture pattern documentation</p> <p>Testing: - Test case contributions for edge scenarios - Performance benchmarking - Integration test examples - Testing pattern documentation</p> <p>Tooling: - IDE plugins and extensions - Build system integrations - Debugging utilities - Code generation tools</p>"},{"location":"roadmap/#feature-requests","title":"Feature Requests","text":"<p>Most Requested Features: 1. Visual flow designer for complex business logic 2. Real-time monitoring dashboard 3. Automatic API documentation generation 4. Migration tools from other architectures 5. Performance profiling integration</p>"},{"location":"roadmap/#platform-specific-enhancements","title":"Platform-Specific Enhancements","text":"<p>Android: - Lifecycle-aware transformers - Integration with Android Architecture Components - Background processing optimizations - ProGuard/R8 optimization rules</p> <p>iOS: - Swift-friendly API surface - UIKit and SwiftUI integration helpers - Background processing support - Memory management optimizations</p> <p>Web: - Service Worker integration - IndexedDB state persistence - WebAssembly optimizations - Framework-specific adapters</p>"},{"location":"roadmap/#research-and-exploration","title":"Research and Exploration","text":""},{"location":"roadmap/#experimental-areas","title":"Experimental Areas","text":"<p>Performance Research: - Zero-copy message passing - Lock-free data structures - Memory pool optimization - Garbage collection optimization</p> <p>Architecture Patterns: - Event sourcing integration - CQRS pattern support - Domain-driven design alignment - Microservice communication patterns</p> <p>Developer Experience: - Visual programming interfaces - Low-code/no-code transformer creation - AI-assisted debugging - Automatic performance optimization</p>"},{"location":"roadmap/#contributing-to-the-roadmap","title":"Contributing to the Roadmap","text":"<p>We welcome community input on our roadmap! Here's how you can contribute:</p>"},{"location":"roadmap/#feedback-channels","title":"Feedback Channels","text":"<ol> <li>GitHub Discussions: Share your use cases and requirements</li> <li>Feature Requests: Submit detailed proposals for new features</li> <li>RFC Process: Participate in design discussions for major features</li> <li>Community Surveys: Provide feedback on priorities and directions</li> </ol>"},{"location":"roadmap/#contribution-guidelines","title":"Contribution Guidelines","text":"<p>For New Features: - Start with a discussion or RFC - Provide clear use cases and benefits - Consider backward compatibility - Include testing and documentation plans</p> <p>For Performance Improvements: - Include benchmarks and metrics - Demonstrate real-world impact - Consider different platform requirements - Provide before/after comparisons</p>"},{"location":"roadmap/#timeline-considerations","title":"Timeline Considerations","text":""},{"location":"roadmap/#factors-affecting-timeline","title":"Factors Affecting Timeline","text":"<p>Community Engagement: - User adoption rate and feedback - Community contribution volume - Enterprise customer requirements</p> <p>Technical Challenges: - Platform-specific implementation complexity - Performance optimization requirements - Integration complexity with existing ecosystems</p> <p>Resource Availability: - Core team capacity - Community contributor availability - Testing and validation resources</p>"},{"location":"roadmap/#flexibility-and-adaptation","title":"Flexibility and Adaptation","text":"<p>This roadmap is a living document that evolves based on: - Community feedback and needs - Technical discoveries and challenges - Market changes and new platform capabilities - Ecosystem evolution (Kotlin, Coroutines, etc.)</p>"},{"location":"roadmap/#success-metrics","title":"Success Metrics","text":"<p>We measure our progress using the following metrics:</p> <p>Adoption Metrics: - Download/usage statistics - Community size and engagement - Number of production deployments - Framework integration adoption</p> <p>Quality Metrics: - Bug report frequency and resolution time - Performance benchmark improvements - Documentation completeness and clarity - Test coverage and reliability</p> <p>Developer Experience: - Setup time for new projects - Learning curve feedback - IDE integration effectiveness - Debugging and troubleshooting efficiency</p> <p>Stay Updated: - Watch our GitHub repository for updates - Join our community discussions - Follow our release announcements - Participate in beta testing programs</p> <p>This roadmap is updated quarterly based on community feedback and development progress.</p>"},{"location":"router/","title":"TransmissionRouter","text":"<p>The TransmissionRouter is the central hub that manages communication between all Transformers in your application. It receives Signals from the UI, distributes them to appropriate Transformers, collects their outputs, and provides streams for data consumption.</p> <p>For Android development, consider using RouterViewModel which provides a simplified, lifecycle-aware wrapper around TransmissionRouter.</p>"},{"location":"router/#basic-setup","title":"Basic Setup","text":""},{"location":"router/#simple-router-creation","title":"Simple Router Creation","text":"<pre><code>val router = TransmissionRouter {\n    addTransformerSet(setOf(\n        UserTransformer(),\n        AuthTransformer(),\n        DataTransformer()\n    ))\n}\n</code></pre>"},{"location":"router/#with-custom-configuration","title":"With Custom Configuration","text":"<pre><code>val router = TransmissionRouter {\n    addTransformerSet(transformers)\n    addDispatcher(Dispatchers.IO) \n    setCapacity(Capacity.High)\n}\n</code></pre>"},{"location":"router/#constructor-parameters","title":"Constructor Parameters","text":"<pre><code>class TransmissionRouter internal constructor(\n    identity: Contract.Identity,\n    transformerSetLoader: TransformerSetLoader? = null,\n    autoInitialization: Boolean = true,\n    capacity: Capacity = Capacity.Default,\n    dispatcher: CoroutineDispatcher = Dispatchers.Default,\n)\n</code></pre> <ul> <li>identity: Unique identifier for the router</li> <li>transformerSetLoader: Lazy loading mechanism for transformers</li> <li>autoInitialization: Whether to initialize automatically (default: true)</li> <li>capacity: Buffer capacity for internal streams</li> <li>dispatcher: Coroutine dispatcher for router operations</li> </ul>"},{"location":"router/#builder-configuration","title":"Builder Configuration","text":""},{"location":"router/#adding-transformers","title":"Adding Transformers","text":"<pre><code>// Direct transformer set\nval router = TransmissionRouter {\n    addTransformerSet(setOf(\n        CounterTransformer(),\n        LoggingTransformer()\n    ))\n}\n\n// Using a loader for lazy initialization\nval router = TransmissionRouter {\n    addLoader(MyTransformerSetLoader())\n}\n</code></pre>"},{"location":"router/#setting-capacity","title":"Setting Capacity","text":"<p>Capacity affects the buffer size of internal streams:</p> <pre><code>val router = TransmissionRouter {\n    addTransformerSet(transformers)\n    setCapacity(Capacity.High) // Higher capacity = better performance under load\n}\n\n// Available capacity options\nenum class Capacity(val value: Int) {\n    Low(64),\n    Default(256), \n    High(1024),\n    Unlimited(Channel.UNLIMITED)\n}\n</code></pre>"},{"location":"router/#custom-dispatcher","title":"Custom Dispatcher","text":"<pre><code>val router = TransmissionRouter {\n    addTransformerSet(transformers)\n    addDispatcher(Dispatchers.IO) // Use IO dispatcher for network/database operations\n}\n</code></pre>"},{"location":"router/#manual-initialization","title":"Manual Initialization","text":"<pre><code>val router = TransmissionRouter {\n    overrideInitialization() // Disable auto-initialization\n}\n\n// Later, initialize manually\nrouter.initialize(myTransformerSetLoader)\n</code></pre>"},{"location":"router/#processing-transmissions","title":"Processing Transmissions","text":""},{"location":"router/#processing-signals","title":"Processing Signals","text":"<pre><code>// Process signals from UI\nrouter.process(UserLoginSignal(credentials))\nrouter.process(RefreshDataSignal)\nrouter.process(CounterSignal.Increment)\n</code></pre>"},{"location":"router/#processing-effects","title":"Processing Effects","text":"<pre><code>// Process effects (typically from other transformers)\nrouter.process(LoggingEffect(\"Manual log entry\"))\nrouter.process(NotificationEffect(\"Custom notification\"))\n</code></pre>"},{"location":"router/#data-streams","title":"Data Streams","text":""},{"location":"router/#observing-all-data","title":"Observing All Data","text":"<pre><code>// Collect all data from all transformers\nlifecycleScope.launch {\n    router.streamData().collect { data -&gt;\n        when (data) {\n            is UserData -&gt; updateUserUI(data)\n            is CounterData -&gt; updateCounterUI(data)\n            is ErrorData -&gt; showError(data)\n        }\n    }\n}\n</code></pre>"},{"location":"router/#filtering-specific-data-types","title":"Filtering Specific Data Types","text":"<pre><code>// Observe only user data\nlifecycleScope.launch {\n    router.streamData&lt;UserData&gt;()\n        .collect { userData -&gt;\n            updateUserProfile(userData)\n        }\n}\n\n// Observe multiple specific types\nlifecycleScope.launch {\n    router.streamData()\n        .filter { it is UserData || it is ProfileData }\n        .collect { data -&gt;\n            when (data) {\n                is UserData -&gt; handleUserData(data)\n                is ProfileData -&gt; handleProfileData(data) \n            }\n        }\n}\n</code></pre>"},{"location":"router/#effect-streams","title":"Effect Streams","text":"<p>Access to the effect stream for monitoring:</p> <pre><code>lifecycleScope.launch {\n    router.streamEffect&lt;LoggingEffect&gt;()\n        .collect { effect -&gt;\n            println(\"Log: ${effect.message}\")\n        }\n}\n</code></pre>"},{"location":"router/#query-helper","title":"Query Helper","text":"<p>The router provides a query helper for debugging and monitoring:</p> <pre><code>val queryHelper: QueryHandler = router.queryHelper\n\n// Use for debugging transformer states\n// (Specific usage depends on your debugging needs)\n</code></pre>"},{"location":"router/#complete-examples","title":"Complete Examples","text":""},{"location":"router/#counter-app-from-sample","title":"Counter App from Sample","text":"<pre><code>// From samples/counter\nclass CounterModule {\n    fun provideTransmissionRouter(): TransmissionRouter {\n        return TransmissionRouter {\n            addTransformerSet(setOf(\n                Worker(\"1\"),\n                Worker(\"2\"),\n                Worker(\"3\")\n            ))\n        }\n    }\n}\n\n// Usage in UI\nclass CounterViewModel(private val router: TransmissionRouter) {\n\n    val counterData = router.streamData&lt;CounterData&gt;()\n        .stateIn(\n            scope = viewModelScope,\n            started = SharingStarted.WhileSubscribed(5000),\n            initialValue = CounterData(\"Initial\")\n        )\n\n    fun lookup() {\n        router.process(CounterSignal.Lookup)\n    }\n}\n</code></pre>"},{"location":"router/#components-app-from-sample","title":"Components App from Sample","text":"<pre><code>// From samples/components  \nclass ComponentsModule {\n    fun provideTransmissionRouter(): TransmissionRouter {\n        return TransmissionRouter {\n            addTransformerSet(setOf(\n                InputTransformer(defaultDispatcher),\n                ColorPickerTransformer(defaultDispatcher),\n                OutputTransformer(defaultDispatcher),\n                MultiOutputTransformer()\n            ))\n            addDispatcher(defaultDispatcher)\n        }\n    }\n}\n\n// Usage with multiple data types\nclass ComponentViewModel(private val router: TransmissionRouter) {\n\n    val uiState = combine(\n        router.streamData&lt;InputUiState&gt;(),\n        router.streamData&lt;OutputCalculationResult&gt;()\n    ) { inputState, outputResult -&gt;\n        SampleScreenUiState(\n            inputState = inputState,\n            outputResult = outputResult\n        )\n    }.stateIn(\n        scope = viewModelScope,\n        started = SharingStarted.WhileSubscribed(5000),\n        initialValue = SampleScreenUiState()\n    )\n\n    fun updateInput(value: String) {\n        router.process(InputSignal.InputUpdate(value))\n    }\n\n    fun selectColor(color: Color) {\n        router.process(ColorPickerSignal.ColorSelected(color))\n    }\n}\n</code></pre>"},{"location":"router/#advanced-features","title":"Advanced Features","text":""},{"location":"router/#custom-transformer-set-loader","title":"Custom Transformer Set Loader","text":"<p>For complex applications, you might want to load transformers dynamically:</p> <pre><code>class CustomTransformerSetLoader : TransformerSetLoader {\n    override suspend fun load(): Set&lt;Transformer&gt; {\n        return buildSet {\n            // Load based on configuration\n            if (isFeatureEnabled(\"auth\")) {\n                add(AuthTransformer())\n            }\n            if (isFeatureEnabled(\"analytics\")) {\n                add(AnalyticsTransformer()) \n            }\n            // Always include core transformers\n            add(CoreTransformer())\n        }\n    }\n}\n\nval router = TransmissionRouter {\n    addLoader(CustomTransformerSetLoader())\n}\n</code></pre>"},{"location":"router/#multiple-routers","title":"Multiple Routers","text":"<p>For large applications, you might use multiple routers:</p> <pre><code>// Feature-specific routers\nval authRouter = TransmissionRouter {\n    addTransformerSet(authTransformers)\n}\n\nval dataRouter = TransmissionRouter {\n    addTransformerSet(dataTransformers)\n}\n\n// Cross-router communication via effects\nauthRouter.streamEffect&lt;UserLoggedInEffect&gt;()\n    .collect { effect -&gt;\n        dataRouter.process(LoadUserDataSignal(effect.userId))\n    }\n</code></pre>"},{"location":"router/#lifecycle-management","title":"Lifecycle Management","text":""},{"location":"router/#proper-cleanup","title":"Proper Cleanup","text":"<pre><code>class MyRepository {\n    private val router = TransmissionRouter { \n        addTransformerSet(transformers)\n    }\n\n    fun cleanup() {\n        router.clear() // Cleans up all transformers and coroutines\n    }\n}\n\n// In Android ViewModel\nclass MyViewModel : ViewModel() {\n    private val router = TransmissionRouter { /* config */ }\n\n    override fun onCleared() {\n        router.clear()\n        super.onCleared()\n    }\n}\n</code></pre>"},{"location":"router/#integration-with-dependency-injection","title":"Integration with Dependency Injection","text":""},{"location":"router/#hilt-example","title":"Hilt Example","text":"<pre><code>@Module\n@InstallIn(SingletonComponent::class)\nobject TransmissionModule {\n\n    @Provides\n    @Singleton\n    fun provideTransformers(): Set&lt;Transformer&gt; = setOf(\n        UserTransformer(),\n        AuthTransformer(),\n        DataTransformer()\n    )\n\n    @Provides\n    @Singleton\n    fun provideTransmissionRouter(\n        transformers: Set&lt;Transformer&gt;\n    ): TransmissionRouter = TransmissionRouter {\n        addTransformerSet(transformers)\n        setCapacity(Capacity.High)\n    }\n}\n</code></pre>"},{"location":"router/#koin-example","title":"Koin Example","text":"<pre><code>val transmissionModule = module {\n    single { UserTransformer() }\n    single { AuthTransformer() }\n    single { DataTransformer() }\n\n    single&lt;Set&lt;Transformer&gt;&gt; { \n        setOf(get&lt;UserTransformer&gt;(), get&lt;AuthTransformer&gt;(), get&lt;DataTransformer&gt;()) \n    }\n\n    single { \n        TransmissionRouter {\n            addTransformerSet(get&lt;Set&lt;Transformer&gt;&gt;())\n            setCapacity(Capacity.High)\n        }\n    }\n}\n</code></pre>"},{"location":"router/#error-handling","title":"Error Handling","text":"<p>The router includes built-in error handling:</p> <pre><code>// Transformer errors are isolated and don't crash the router\n// Individual transformers can override onError() to handle their own errors\n\nclass SafeTransformer : Transformer() {\n    override fun onError(throwable: Throwable) {\n        // Handle transformer-specific errors\n        publish(ErrorEffect(\"Transformer error: ${throwable.message}\"))\n    }\n}\n</code></pre>"},{"location":"router/#performance-considerations","title":"Performance Considerations","text":""},{"location":"router/#capacity-settings","title":"Capacity Settings","text":"<pre><code>// For high-throughput applications\nval router = TransmissionRouter {\n    addTransformerSet(transformers)\n    setCapacity(Capacity.High) // or Capacity.Unlimited for extreme cases\n}\n\n// For memory-constrained environments\nval router = TransmissionRouter {\n    addTransformerSet(transformers) \n    setCapacity(Capacity.Low)\n}\n</code></pre>"},{"location":"router/#dispatcher-selection","title":"Dispatcher Selection","text":"<pre><code>// For CPU-intensive work\nval router = TransmissionRouter {\n    addTransformerSet(transformers)\n    addDispatcher(Dispatchers.Default)\n}\n\n// For IO-intensive work\nval router = TransmissionRouter {\n    addTransformerSet(transformers)\n    addDispatcher(Dispatchers.IO)\n}\n\n// For UI-related work (use sparingly)\nval router = TransmissionRouter {\n    addTransformerSet(transformers)\n    addDispatcher(Dispatchers.Main.immediate)\n}\n</code></pre>"},{"location":"router/#routerviewmodel","title":"RouterViewModel","text":"<p>RouterViewModel is a convenience wrapper around TransmissionRouter that extends <code>androidx.lifecycle.ViewModel</code>. It's fully Kotlin Multiplatform compatible and provides automatic setup, lifecycle management, and simplified stream handling across all platforms.</p>"},{"location":"router/#key-features","title":"Key Features","text":"<ul> <li>Automatic Setup: Router is configured and initialized automatically</li> <li>Lifecycle Management: Router cleanup is handled in <code>onCleared()</code></li> <li>Stream Collection: Data and effect streams are automatically collected in <code>viewModelScope</code></li> <li>Hook Methods: Override <code>onData</code>, <code>onEffect</code>, <code>onProcessSignal</code>, and <code>onProcessEffect</code> for custom logic</li> <li>Query Support: Built-in access to <code>QueryHandler</code> for querying transformer states</li> <li>StateFlow Helpers: Built-in methods for converting streams to StateFlow</li> <li>Error Handling: Built-in error handling with <code>onError</code> callback</li> </ul>"},{"location":"router/#basic-usage","title":"Basic Usage","text":""},{"location":"router/#simple-implementation","title":"Simple Implementation","text":"<pre><code>class UserViewModel : RouterViewModel(\n    setOf(\n        UserTransformer(),\n        AuthTransformer(),\n        ProfileTransformer()\n    )\n) {\n    // Create StateFlow from data streams\n    val userState = streamDataAsState&lt;UserData&gt;(UserData.Empty)\n    val authState = streamDataAsState&lt;AuthData&gt;(AuthData.LoggedOut)\n\n    // Handle data updates\n    override fun onData(data: Transmission.Data) {\n        when (data) {\n            is UserData -&gt; logUserUpdate(data)\n            is AuthData -&gt; handleAuthChange(data)\n        }\n    }\n\n    // Handle effects\n    override fun onEffect(effect: Transmission.Effect) {\n        when (effect) {\n            is NavigationEffect -&gt; navigateTo(effect.destination)\n            is ErrorEffect -&gt; showError(effect.message)\n        }\n    }\n\n    // User actions\n    fun login(credentials: Credentials) {\n        processSignal(AuthSignal.Login(credentials))\n    }\n\n    fun updateProfile(profile: Profile) {\n        processSignal(UserSignal.UpdateProfile(profile))\n    }\n}\n</code></pre>"},{"location":"router/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>class FeatureViewModel : RouterViewModel(\n    loader = FeatureTransformerSetLoader(),\n    config = RouterViewModelConfig(\n        capacity = Capacity.High,\n        dispatcher = Dispatchers.IO,\n        identity = Contract.identity(\"feature-router\")\n    )\n) {\n    // Type-safe stream access\n    val errorStream = streamEffect&lt;ErrorEffect&gt;()\n    val loadingData = streamData&lt;LoadingData&gt;()\n\n    // Custom error handling\n    override fun onError(throwable: Throwable) {\n        logError(\"Router error\", throwable)\n        processEffect(ErrorEffect(\"System error occurred\"))\n    }\n\n    // Post-processing hooks\n    override fun onProcessSignal(signal: Transmission.Signal) {\n        analytics.trackSignal(signal::class.simpleName)\n    }\n\n    // Query transformer states\n    suspend fun getCurrentUserData(): UserData? {\n        return queryHandler.getData(UserTransformer.dataContract)\n    }\n}\n</code></pre>"},{"location":"router/#configuration-options","title":"Configuration Options","text":""},{"location":"router/#routerviewmodelconfig","title":"RouterViewModelConfig","text":"<pre><code>data class RouterViewModelConfig(\n    val capacity: Capacity = Capacity.Default,           // Buffer capacity\n    val dispatcher: CoroutineDispatcher = Dispatchers.Default, // Coroutine dispatcher\n    val identity: Contract.Identity = Contract.identity()       // Router identity\n)\n</code></pre>"},{"location":"router/#usage-with-configuration","title":"Usage with Configuration","text":"<pre><code>// High-performance configuration\nval config = RouterViewModelConfig(\n    capacity = Capacity.High,\n    dispatcher = Dispatchers.IO\n)\n\nclass MyViewModel : RouterViewModel(transformers, config) {\n    // Implementation\n}\n</code></pre>"},{"location":"router/#stream-helpers","title":"Stream Helpers","text":""},{"location":"router/#stateflow-creation","title":"StateFlow Creation","text":"<pre><code>class ShoppingViewModel : RouterViewModel(shoppingTransformers) {\n    // Automatic StateFlow conversion\n    val cartState = streamDataAsState&lt;CartData&gt;(CartData.Empty)\n    val productsState = streamDataAsState&lt;ProductListData&gt;(ProductListData.Loading)\n    val checkoutState = streamDataAsState&lt;CheckoutData&gt;(CheckoutData.Idle)\n\n    // Custom sharing behavior\n    val userPreferences = streamDataAsState&lt;UserPreferencesData&gt;(\n        initialValue = UserPreferencesData.Default,\n        started = SharingStarted.Eagerly\n    )\n}\n</code></pre>"},{"location":"router/#type-safe-stream-access","title":"Type-Safe Stream Access","text":"<pre><code>class ChatViewModel : RouterViewModel(chatTransformers) {\n    // Access specific data types\n    val messageFlow = streamData&lt;MessageData&gt;()\n    val userStatusFlow = streamData&lt;UserStatusData&gt;()\n\n    // Access specific effect types  \n    val notificationEffects = streamEffect&lt;NotificationEffect&gt;()\n    val navigationEffects = streamEffect&lt;NavigationEffect&gt;()\n\n    init {\n        // Custom stream handling\n        viewModelScope.launch {\n            navigationEffects.collect { effect -&gt;\n                handleNavigation(effect)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"router/#dependency-injection-integration","title":"Dependency Injection Integration","text":""},{"location":"router/#hilt-example_1","title":"Hilt Example","text":"<pre><code>@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val transformerSetLoader: MainTransformerSetLoader\n) : RouterViewModel(\n    loader = transformerSetLoader,\n    config = RouterViewModelConfig(capacity = Capacity.High)\n) {\n    val mainState = streamDataAsState&lt;MainScreenData&gt;(MainScreenData.Loading)\n\n    fun refreshData() {\n        processSignal(RefreshSignal)\n    }\n}\n</code></pre>"},{"location":"router/#koin-example_1","title":"Koin Example","text":"<pre><code>val viewModelModule = module {\n    viewModel { \n        UserViewModel(\n            transformerSet = get&lt;Set&lt;Transformer&gt;&gt;(),\n            config = RouterViewModelConfig(\n                dispatcher = get(named(\"ioDispatcher\"))\n            )\n        )\n    }\n}\n\nclass UserViewModel(\n    transformerSet: Set&lt;Transformer&gt;,\n    config: RouterViewModelConfig\n) : RouterViewModel(transformerSet, config) {\n    // Implementation\n}\n</code></pre>"},{"location":"router/#error-handling_1","title":"Error Handling","text":"<pre><code>class RobustViewModel : RouterViewModel(transformers) {\n    override fun onError(throwable: Throwable) {\n        when (throwable) {\n            is NetworkException -&gt; handleNetworkError(throwable)\n            is ValidationException -&gt; handleValidationError(throwable)\n            else -&gt; {\n                logError(\"Unexpected router error\", throwable)\n                processEffect(ErrorEffect(\"Something went wrong\"))\n            }\n        }\n    }\n\n    override fun onProcessSignal(signal: Transmission.Signal) {\n        // Log all processed signals for debugging\n        if (BuildConfig.DEBUG) {\n            Log.d(\"RouterViewModel\", \"Processed signal: $signal\")\n        }\n    }\n}\n</code></pre>"},{"location":"router/#multiplatform-support","title":"Multiplatform Support","text":"<p>RouterViewModel is built using <code>androidx.lifecycle.ViewModel</code> which is fully multiplatform:</p> <pre><code>import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\n</code></pre> <p>This means you can use RouterViewModel across all supported platforms: - Android: Native AndroidX ViewModel support - iOS: Full lifecycle management via androidx.lifecycle-viewmodel - Desktop: JVM-based lifecycle management - Web: Kotlin/JS lifecycle management</p>"},{"location":"router/#platform-specific-considerations","title":"Platform-Specific Considerations","text":"<p>While RouterViewModel works on all platforms, you may want different configurations per platform:</p> <pre><code>// Platform-specific configurations\nexpect fun defaultRouterConfig(): RouterViewModelConfig\n\n// androidMain\nactual fun defaultRouterConfig() = RouterViewModelConfig(\n    capacity = Capacity.High,\n    dispatcher = Dispatchers.Main.immediate\n)\n\n// iosMain  \nactual fun defaultRouterConfig() = RouterViewModelConfig(\n    capacity = Capacity.Default,\n    dispatcher = Dispatchers.Main\n)\n\n// Usage\nclass MyViewModel : RouterViewModel(\n    transformers = myTransformers,\n    config = defaultRouterConfig()\n)\n\n## Comparison: Direct Router vs RouterViewModel\n\n### Direct TransmissionRouter\n\n```kotlin\nclass ManualViewModel : ViewModel() {\n    private val router = TransmissionRouter {\n        addTransformerSet(transformers)\n    }\n\n    val dataState = router.streamData&lt;MyData&gt;()\n        .stateIn(viewModelScope, SharingStarted.WhileSubscribed(), MyData.Empty)\n\n    init {\n        viewModelScope.launch {\n            router.streamEffect&lt;MyEffect&gt;().collect { effect -&gt;\n                handleEffect(effect)\n            }\n        }\n    }\n\n    fun processUserAction(action: MySignal) {\n        router.process(action)\n    }\n\n    override fun onCleared() {\n        router.clear()\n        super.onCleared()\n    }\n}\n</code></pre>"},{"location":"router/#routerviewmodel_1","title":"RouterViewModel","text":"<pre><code>class SimpleViewModel : RouterViewModel(transformers) {\n    val dataState = streamDataAsState&lt;MyData&gt;(MyData.Empty)\n\n    override fun onEffect(effect: Transmission.Effect) {\n        if (effect is MyEffect) {\n            handleEffect(effect)\n        }\n    }\n\n    fun processUserAction(action: MySignal) {\n        processSignal(action)\n    }\n\n    // Cleanup is automatic!\n}\n</code></pre>"},{"location":"router/#best-practices-for-routerviewmodel","title":"Best Practices for RouterViewModel","text":""},{"location":"router/#1-use-stateflow-for-ui-state","title":"1. Use StateFlow for UI State","text":"<pre><code>class GoodViewModel : RouterViewModel(transformers) {\n    // \u2705 Good: Direct StateFlow creation\n    val uiState = streamDataAsState&lt;UiState&gt;(UiState.Loading)\n\n    // \u274c Avoid: Manual StateFlow conversion in ViewModels\n    // val uiState = streamData&lt;UiState&gt;()\n    //     .stateIn(viewModelScope, SharingStarted.WhileSubscribed(), UiState.Loading)\n}\n</code></pre>"},{"location":"router/#2-handle-effects-properly","title":"2. Handle Effects Properly","text":"<pre><code>class EffectHandlingViewModel : RouterViewModel(transformers) {\n    override fun onEffect(effect: Transmission.Effect) {\n        when (effect) {\n            is NavigationEffect -&gt; {\n                // Handle navigation - don't process signals here\n                navigationManager.navigateTo(effect.destination)\n            }\n            is ValidationEffect -&gt; {\n                // Handle validation feedback\n                showValidationError(effect.message)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"router/#3-use-configuration-for-performance","title":"3. Use Configuration for Performance","text":"<pre><code>// \u2705 Good: Configure based on use case\nclass HighThroughputViewModel : RouterViewModel(\n    transformers = heavyTransformers,\n    config = RouterViewModelConfig(\n        capacity = Capacity.High,\n        dispatcher = Dispatchers.Default\n    )\n)\n\nclass IOIntensiveViewModel : RouterViewModel(\n    transformers = networkTransformers,\n    config = RouterViewModelConfig(\n        dispatcher = Dispatchers.IO\n    )\n)\n</code></pre>"},{"location":"router/#best-practices","title":"Best Practices","text":"<ol> <li>Single Router per Feature: Use one router per logical feature or module</li> <li>Proper Cleanup: Always call <code>router.clear()</code> when done</li> <li>Appropriate Capacity: Choose capacity based on your app's throughput needs</li> <li>Error Handling: Implement proper error handling in transformers</li> <li>Stream Management: Use appropriate lifecycle scopes for data stream collection</li> <li>Testing: The router is designed to be easily testable - see Testing guide</li> </ol>"},{"location":"setup/","title":"Setting Up","text":"<p>This guide provides instructions for adding the Transmission library to your Kotlin Multiplatform project.</p>"},{"location":"setup/#gradle-setup","title":"Gradle Setup","text":""},{"location":"setup/#maven-central-recommended-version-160","title":"Maven Central (Recommended - Version 1.6.0+)","text":"<p>Starting from version 1.6.0, Transmission is published to Maven Central for better Kotlin Multiplatform support.</p> <p>Add the dependency to your app's build.gradle file:</p> <pre><code>// In your app's build.gradle file\ndependencies {\n    implementation 'com.trendyol:transmission:&lt;latest-version&gt;'\n\n    // For Android ViewModel integration\n    implementation 'com.trendyol:transmission-viewmodel:&lt;latest-version&gt;'\n\n    // If you need testing utilities\n    testImplementation 'com.trendyol:transmission-test:&lt;latest-version&gt;'\n}\n</code></pre> <p>Or in Kotlin DSL:</p> <pre><code>// In your app's build.gradle.kts file\ndependencies {\n    implementation(\"com.trendyol:transmission:&lt;latest-version&gt;\")\n\n    // For Android ViewModel integration\n    implementation(\"com.trendyol:transmission-viewmodel:&lt;latest-version&gt;\")\n\n    // If you need testing utilities\n    testImplementation(\"com.trendyol:transmission-test:&lt;latest-version&gt;\")\n}\n</code></pre>"},{"location":"setup/#jitpack-for-versions-up-to-150","title":"JitPack (For Versions up to 1.5.0)","text":"<p>For versions 1.5.0 and earlier, you can use JitPack:</p>"},{"location":"setup/#step-1-add-jitpack-repository","title":"Step 1: Add JitPack Repository","text":"<p>Add the JitPack repository to your root build.gradle file:</p> <pre><code>// In your root build.gradle file\nallprojects {\n    repositories {\n        // Other repositories\n        maven { url 'https://jitpack.io' }\n    }\n}\n</code></pre> <p>Or in your settings.gradle.kts file if using the new Gradle setup:</p> <pre><code>// In your settings.gradle.kts file\ndependencyResolutionManagement {\n    repositories {\n        // Other repositories\n        maven(\"https://jitpack.io\")\n    }\n}\n</code></pre>"},{"location":"setup/#step-2-add-the-jitpack-dependency","title":"Step 2: Add the JitPack Dependency","text":"<pre><code>// In your app's build.gradle file\ndependencies {\n    implementation 'com.github.Trendyol:transmission:&lt;version-up-to-1.5.0&gt;'\n\n    // If you need testing utilities\n    testImplementation 'com.github.Trendyol:transmission:transmission-test:&lt;version-up-to-1.5.0&gt;'\n}\n</code></pre> <p>Or in Kotlin DSL:</p> <pre><code>// In your app's build.gradle.kts file\ndependencies {\n    implementation(\"com.github.Trendyol:transmission:&lt;version-up-to-1.5.0&gt;\")\n\n    // If you need testing utilities\n    testImplementation(\"com.github.Trendyol:transmission:transmission-test:&lt;version-up-to-1.5.0&gt;\")\n}\n</code></pre> <p>Replace <code>&lt;latest-version&gt;</code> with the latest version from GitHub Releases.</p>"},{"location":"setup/#project-structure","title":"Project Structure","text":"<p>For a well-organized project using Transmission, consider the following structure:</p> <pre><code>app/\n\u251c\u2500\u2500 src/main/java/com/yourpackage/\n\u2502   \u251c\u2500\u2500 ui/           # UI Components\n\u2502   \u251c\u2500\u2500 data/         # Data models\n\u2502   \u251c\u2500\u2500 transmission/ # Transmission components\n\u2502   \u2502   \u251c\u2500\u2500 signals/  # Signal definitions\n\u2502   \u2502   \u251c\u2500\u2500 effects/  # Effect definitions\n\u2502   \u2502   \u251c\u2500\u2500 data/     # Data definitions\n\u2502   \u2502   \u251c\u2500\u2500 transformers/ # Transformer implementations\n\u2502   \u2502   \u2514\u2500\u2500 contracts/ # Contract definitions\n\u2502   \u2514\u2500\u2500 di/           # Dependency injection\n\u251c\u2500\u2500 ...\n</code></pre>"},{"location":"setup/#complete-project-example","title":"Complete Project Example","text":"<p>Here's a complete example of setting up Transmission in a multiplatform project:</p>"},{"location":"setup/#module-structure","title":"Module Structure","text":"<pre><code>project/\n\u251c\u2500\u2500 shared/\n\u2502   \u251c\u2500\u2500 src/commonMain/kotlin/\n\u2502   \u2502   \u251c\u2500\u2500 transmission/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 signals/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 effects/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 data/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 transformers/\n\u2502   \u2502   \u2514\u2500\u2500 di/\n\u2502   \u2514\u2500\u2500 build.gradle.kts\n\u251c\u2500\u2500 androidApp/\n\u2514\u2500\u2500 iosApp/\n</code></pre>"},{"location":"setup/#sharedbuildgradlekts","title":"shared/build.gradle.kts","text":"<pre><code>plugins {\n    kotlin(\"multiplatform\")\n    kotlin(\"native.cocoapods\")\n    id(\"com.android.library\")\n}\n\nkotlin {\n    android()\n    iosX64()\n    iosArm64()\n    iosSimulatorArm64()\n\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(\"com.trendyol:transmission:&lt;latest-version&gt;\")\n                implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3\")\n            }\n        }\n\n        val commonTest by getting {\n            dependencies {\n                implementation(kotlin(\"test\"))\n                implementation(\"com.trendyol:transmission-test:&lt;latest-version&gt;\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"setup/#dependency-injection-setup","title":"Dependency Injection Setup","text":""},{"location":"setup/#with-koin-multiplatform","title":"With Koin (Multiplatform)","text":"<pre><code>// shared/src/commonMain/kotlin/di/TransmissionModule.kt\nval transmissionModule = module {\n    // Define transformers\n    single { UserTransformer() }\n    single { AuthTransformer() }\n    single { DataTransformer() }\n\n    // Create transformer set\n    single&lt;Set&lt;Transformer&gt;&gt; { \n        setOf(\n            get&lt;UserTransformer&gt;(), \n            get&lt;AuthTransformer&gt;(), \n            get&lt;DataTransformer&gt;()\n        ) \n    }\n\n    // Define router\n    single { \n        TransmissionRouter {\n            addTransformerSet(get&lt;Set&lt;Transformer&gt;&gt;())\n            setCapacity(Capacity.High)\n        }\n    }\n}\n\n// In your app initialization\nfun initKoin() {\n    startKoin {\n        modules(transmissionModule)\n    }\n}\n</code></pre> <p>If you're using a dependency injection framework like Hilt (Android) or Koin, you can create a module for your Transmission components:</p>"},{"location":"setup/#hilt-example","title":"Hilt Example","text":"<pre><code>@Module\n@InstallIn(SingletonComponent::class)\nobject TransmissionModule {\n\n    @Provides\n    @Singleton\n    fun provideTransformers(): Set&lt;Transformer&gt; = setOf(\n        MyTransformer1(),\n        MyTransformer2(),\n        MyTransformer3()\n    )\n\n    @Provides\n    @Singleton\n    fun provideTransmissionRouter(\n        transformers: Set&lt;Transformer&gt;\n    ): TransmissionRouter = TransmissionRouter {\n        addTransformerSet(transformers)\n    }\n}\n</code></pre>"},{"location":"setup/#koin-example","title":"Koin Example","text":"<pre><code>val transmissionModule = module {\n    // Define transformers\n    single { MyTransformer1() }\n    single { MyTransformer2() }\n    single { MyTransformer3() }\n\n    // Create a set of all transformers\n    single&lt;Set&lt;Transformer&gt;&gt; { \n        setOf(get&lt;MyTransformer1&gt;(), get&lt;MyTransformer2&gt;(), get&lt;MyTransformer3&gt;()) \n    }\n\n    // Define router\n    single { \n        TransmissionRouter {\n            addTransformerSet(get&lt;Set&lt;Transformer&gt;&gt;())\n        }\n    }\n}\n</code></pre>"},{"location":"setup/#routerviewmodel-setup-multiplatform","title":"RouterViewModel Setup (Multiplatform)","text":""},{"location":"setup/#routerviewmodel-module","title":"RouterViewModel Module","text":"<p>For multiplatform projects using ViewModels, add the RouterViewModel dependency:</p> <pre><code>// Multiplatform module build.gradle.kts\nkotlin {\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                implementation(\"com.trendyol:transmission:&lt;latest-version&gt;\")\n                implementation(\"com.trendyol:transmission-viewmodel:&lt;latest-version&gt;\")\n\n                // Multiplatform ViewModel\n                implementation(\"androidx.lifecycle:lifecycle-viewmodel:2.7.0\")\n            }\n        }\n    }\n}\n\n// Or for Android-only module\ndependencies {\n    implementation(\"com.trendyol:transmission:&lt;latest-version&gt;\")\n    implementation(\"com.trendyol:transmission-viewmodel:&lt;latest-version&gt;\")\n\n    // ViewModel and Lifecycle\n    implementation(\"androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0\")\n    implementation(\"androidx.lifecycle:lifecycle-runtime-compose:2.7.0\")\n}\n</code></pre>"},{"location":"setup/#with-dependency-injection","title":"With Dependency Injection","text":""},{"location":"setup/#hilt-routerviewmodel","title":"Hilt + RouterViewModel","text":"<pre><code>// Module setup\n@Module\n@InstallIn(SingletonComponent::class)\nobject TransmissionModule {\n\n    @Provides\n    @Singleton\n    fun provideTransformers(): Set&lt;Transformer&gt; = setOf(\n        UserTransformer(),\n        AuthTransformer(),\n        DataTransformer()\n    )\n\n    @Provides\n    @Singleton\n    fun provideTransformerSetLoader(\n        transformers: Set&lt;Transformer&gt;\n    ): TransformerSetLoader = object : TransformerSetLoader {\n        override suspend fun load(): Set&lt;Transformer&gt; = transformers\n    }\n}\n\n// ViewModel with injection\n@HiltViewModel\nclass MainViewModel @Inject constructor(\n    private val transformerSetLoader: TransformerSetLoader\n) : RouterViewModel(\n    loader = transformerSetLoader,\n    config = RouterViewModelConfig(\n        capacity = Capacity.High,\n        dispatcher = Dispatchers.IO\n    )\n) {\n    val uiState = streamDataAsState&lt;UiState&gt;(UiState.Loading)\n\n    fun handleUserAction(action: UserAction) {\n        processSignal(UserSignal.Action(action))\n    }\n}\n</code></pre>"},{"location":"setup/#koin-routerviewmodel","title":"Koin + RouterViewModel","text":"<pre><code>// Koin module\nval androidTransmissionModule = module {\n    // Transformers\n    single { UserTransformer() }\n    single { AuthTransformer() }\n    single { DataTransformer() }\n\n    // Transformer set\n    single&lt;Set&lt;Transformer&gt;&gt; { \n        setOf(get&lt;UserTransformer&gt;(), get&lt;AuthTransformer&gt;(), get&lt;DataTransformer&gt;()) \n    }\n\n    // RouterViewModel configuration\n    single { \n        RouterViewModelConfig(\n            capacity = Capacity.High,\n            dispatcher = get(named(\"ioDispatcher\"))\n        )\n    }\n\n    // ViewModels\n    viewModel { \n        UserViewModel(\n            transformerSet = get&lt;Set&lt;Transformer&gt;&gt;(),\n            config = get&lt;RouterViewModelConfig&gt;()\n        )\n    }\n}\n\n// ViewModel implementation\nclass UserViewModel(\n    transformerSet: Set&lt;Transformer&gt;,\n    config: RouterViewModelConfig\n) : RouterViewModel(transformerSet, config) {\n\n    val userState = streamDataAsState&lt;UserData&gt;(UserData.Empty)\n    val loadingState = streamDataAsState&lt;LoadingData&gt;(LoadingData.Idle)\n\n    override fun onEffect(effect: Transmission.Effect) {\n        when (effect) {\n            is NavigationEffect -&gt; handleNavigation(effect)\n            is ErrorEffect -&gt; showError(effect.message)\n        }\n    }\n\n    fun login(credentials: Credentials) {\n        processSignal(AuthSignal.Login(credentials))\n    }\n}\n</code></pre>"},{"location":"setup/#compose-integration","title":"Compose Integration","text":"<pre><code>// Compose usage with RouterViewModel\n@Composable\nfun UserScreen(\n    viewModel: UserViewModel = hiltViewModel()\n) {\n    val userState by viewModel.userState.collectAsState()\n    val loadingState by viewModel.loadingState.collectAsState()\n\n    when (loadingState) {\n        is LoadingData.Loading -&gt; LoadingIndicator()\n        is LoadingData.Error -&gt; ErrorMessage(loadingState.message)\n        else -&gt; {\n            UserContent(\n                userData = userState,\n                onLoginClick = { credentials -&gt;\n                    viewModel.login(credentials)\n                }\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"setup/#proguard-r8-configuration","title":"Proguard / R8 Configuration","text":"<p>If you're using ProGuard or R8, add the following rules to your ProGuard configuration:</p> <pre><code># Transmission Library\n-keep class com.trendyol.transmission.** { *; }\n-keepclassmembers class * implements com.trendyol.transmission.Transmission { *; }\n\n# RouterViewModel (if using)\n-keep class com.trendyol.transmissionviewmodel.** { *; }\n</code></pre> <p>This ensures that your Transmission interfaces and classes are not obfuscated, which is important for reflection-based operations in the library.</p>"},{"location":"testing/","title":"Testing","text":"<p>The Transmission library includes a comprehensive testing framework that makes it easy to test your Transformers, business logic, and communication flows in isolation.</p>"},{"location":"testing/#testing-dependencies","title":"Testing Dependencies","text":"<p>Add the testing module to your project:</p> <pre><code>// build.gradle.kts\ndependencies {\n    testImplementation(\"com.trendyol:transmission-test:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"testing/#imports","title":"Imports","text":"<p>For testing, you'll typically need these imports:</p> <pre><code>import com.trendyol.transmission.test.*\nimport org.junit.jupiter.api.Test\nimport kotlin.test.assertEquals\nimport kotlin.test.assertNotNull\nimport kotlin.test.assertTrue\nimport kotlin.test.assertFalse\n</code></pre>"},{"location":"testing/#basic-testing","title":"Basic Testing","text":""},{"location":"testing/#testing-a-simple-transformer","title":"Testing a Simple Transformer","text":"<pre><code>@Test\nfun `should increment counter when receiving increment signal`() {\n    val transformer = CounterTransformer()\n\n    transformer.test()\n        .testSignal(CounterSignal.Increment) {\n            // Verify data output\n            val data = lastData&lt;CounterData&gt;()\n            assertEquals(1, data?.count)\n        }\n}\n</code></pre>"},{"location":"testing/#testing-signal-handlers","title":"Testing Signal Handlers","text":"<pre><code>@Test\nfun `should handle user login correctly`() {\n    val authTransformer = AuthTransformer()\n\n    authTransformer.test()\n        .testSignal(UserLoginSignal(validCredentials)) {\n            // Verify successful login data\n            val userData = lastData&lt;UserData&gt;()\n            assertEquals(\"John Doe\", userData?.user?.name)\n            assertTrue(userData?.isAuthenticated == true)\n\n            // Verify navigation effect\n            val navEffect = lastEffect&lt;NavigationEffect.GoToHome&gt;()\n            assertNotNull(navEffect)\n\n            // Verify no error data\n            assertFalse(hasData&lt;ErrorData&gt;())\n        }\n}\n</code></pre>"},{"location":"testing/#testing-effect-handlers","title":"Testing Effect Handlers","text":"<pre><code>@Test\nfun `should process refresh effect correctly`() {\n    val dataTransformer = DataTransformer()\n\n    dataTransformer.test()\n        .testEffect(RefreshDataEffect) {\n            // Verify data is refreshed\n            val data = lastData&lt;FreshData&gt;()\n            assertNotNull(data?.content)\n            assertTrue(data?.timestamp?.let { it &gt; 0 } == true)\n        }\n}\n</code></pre>"},{"location":"testing/#testing-with-mocking","title":"Testing with Mocking","text":""},{"location":"testing/#mocking-data","title":"Mocking Data","text":"<pre><code>@Test\nfun `should handle mocked computation data`() {\n    val transformer = UserTransformer()\n\n    transformer.test()\n        .withData(UserTransformer.getCurrentUserContract, mockUserData)\n        .testSignal(UpdateUserSignal(\"New Name\", \"new@email.com\")) {\n            val state = lastData&lt;UserState&gt;()\n            assertEquals(\"New Name\", state?.user?.name)\n            assertEquals(\"new@email.com\", state?.user?.email)\n        }\n}\n</code></pre>"},{"location":"testing/#mocking-computations","title":"Mocking Computations","text":"<pre><code>@Test\nfun `should use mocked computation results`() {\n    val calculatorTransformer = CalculatorTransformer()\n\n    calculatorTransformer.test()\n        .withComputation(CalculatorTransformer.getCurrentValueContract, 42)\n        .withComputation(CalculatorTransformer.addNumbersContract, 15)\n        .testSignal(CalculateSignal) {\n            val result = lastData&lt;CalculationResult&gt;()\n            assertEquals(42, result?.currentValue)\n            assertEquals(15, result?.additionResult)\n        }\n}\n</code></pre>"},{"location":"testing/#testing-with-checkpoints","title":"Testing with Checkpoints","text":"<pre><code>@Test\nfun `should handle checkpoint-based flow`() {\n    val transformer = InputTransformer()\n\n    transformer.test()\n        .withCheckpoint(InputTransformer.colorCheckpoint, Color.Gray)\n        .testSignal(InputSignal.InputUpdate(\"test\")) {\n            assertEquals(InputEffect.InputUpdate(\"test\"), lastEffect())\n            assertEquals(InputUiState(\"test\"), lastData())\n        }\n}\n</code></pre>"},{"location":"testing/#testing-with-initial-processing","title":"Testing with Initial Processing","text":"<pre><code>@Test\nfun `should handle initial processing setup`() {\n    val transformer = DataTransformer()\n    val initialTransmissions = listOf(\n        DataSignal.Initialize,\n        DataSignal.LoadDefaults\n    )\n\n    transformer.test()\n        .withInitialProcessing(initialTransmissions)\n        .testSignal(DataSignal.Process) {\n            assertTrue(hasData&lt;InitializedData&gt;())\n            assertTrue(hasData&lt;DefaultsData&gt;())\n            assertTrue(hasData&lt;ProcessedData&gt;())\n        }\n}\n</code></pre>"},{"location":"testing/#testing-complex-flows","title":"Testing Complex Flows","text":""},{"location":"testing/#testing-effect-chains","title":"Testing Effect Chains","text":"<pre><code>@Test\nfun `should process validation chain correctly`() {\n    val validationTransformer = ValidationChainTransformer()\n\n    validationTransformer.test()\n        .testSignal(ValidateDataSignal(validTestData)) {\n            // Should progress through validation stages\n            assertTrue(hasEffect&lt;ValidateFormatEffect&gt;())\n            assertTrue(hasEffect&lt;ValidateBusinessRulesEffect&gt;())\n            assertTrue(hasEffect&lt;ValidateSecurityEffect&gt;())\n\n            // Should end with successful validation\n            assertTrue(hasData&lt;ValidationPassed&gt;())\n            assertFalse(hasData&lt;ValidationFailed&gt;())\n        }\n}\n\n@Test\nfun `should fail validation chain on invalid data`() {\n    val validationTransformer = ValidationChainTransformer()\n\n    validationTransformer.test()\n        .testSignal(ValidateDataSignal(invalidTestData)) {\n            // Should fail at format validation\n            assertTrue(hasEffect&lt;ValidateFormatEffect&gt;())\n            assertFalse(hasEffect&lt;ValidateBusinessRulesEffect&gt;())\n\n            // Should send failure data\n            val failure = lastData&lt;ValidationFailed&gt;()\n            assertEquals(\"Invalid format\", failure?.reason)\n        }\n}\n</code></pre>"},{"location":"testing/#testing-state-machines","title":"Testing State Machines","text":"<pre><code>@Test\nfun `should transition order states correctly`() {\n    val orderStateMachine = OrderStateMachineTransformer()\n\n    orderStateMachine.test()\n        .testSignal(ProcessOrderSignal(\"order-123\")) {\n            // Verify state transitions through multiple data emissions\n            val states = allData&lt;OrderState&gt;()\n            assertTrue(states.any { it is OrderState.Processing })\n\n            // Verify final state\n            val finalState = lastData&lt;OrderState&gt;()\n            assertTrue(finalState is OrderState.Completed)\n\n            // Verify effects\n            assertTrue(hasEffect&lt;StartOrderProcessingEffect&gt;())\n            assertTrue(hasEffect&lt;OrderCompletedEffect&gt;())\n        }\n        .testEffect(OrderProcessingCompleteEffect(\"order-123\")) {\n            val completedState = lastData&lt;OrderState&gt;()\n            assertTrue(completedState is OrderState.Completed)\n        }\n}\n</code></pre>"},{"location":"testing/#testing-error-handling","title":"Testing Error Handling","text":""},{"location":"testing/#testing-exception-handling","title":"Testing Exception Handling","text":"<pre><code>@Test\nfun `should handle errors gracefully`() {\n    val riskyTransformer = RiskyTransformer()\n\n    riskyTransformer.test()\n        .testSignal(RiskyOperationSignal(invalidData)) {\n            // Should produce error data instead of crashing\n            val error = lastData&lt;ErrorData&gt;()\n            assertTrue(error?.message?.contains(\"Invalid data\") == true)\n\n            // Should not produce success data\n            assertFalse(hasData&lt;SuccessData&gt;())\n        }\n}\n</code></pre>"},{"location":"testing/#testing-fallback-mechanisms","title":"Testing Fallback Mechanisms","text":"<pre><code>@Test\nfun `should fallback when external service fails`() {\n    val serviceTransformer = ExternalServiceTransformer()\n\n    serviceTransformer.test()\n        .withComputation(ExternalServiceTransformer.serviceContract, null) // Mock failure\n        .testSignal(CallExternalServiceSignal(\"test-request\")) {\n            // Should use fallback\n            val fallbackData = lastData&lt;FallbackData&gt;()\n            assertEquals(\"fallback-response\", fallbackData?.content)\n\n            assertTrue(hasEffect&lt;ServiceFailureLoggedEffect&gt;())\n        }\n}\n</code></pre>"},{"location":"testing/#testing-with-real-examples","title":"Testing with Real Examples","text":""},{"location":"testing/#counter-sample-test","title":"Counter Sample Test","text":"<pre><code>@Test\nfun `worker should process lookup signal correctly`() {\n    val worker = Worker(\"test-worker\")\n\n    worker.test()\n        .testSignal(CounterSignal.Lookup) {\n            val data = lastData&lt;CounterData&gt;()\n            assertTrue(data?.id?.contains(\"test-worker\") == true)\n        }\n}\n</code></pre>"},{"location":"testing/#components-sample-test","title":"Components Sample Test","text":"<pre><code>@Test\nfun `input transformer should handle input updates`() {\n    val inputTransformer = InputTransformer(Dispatchers.Unconfined)\n\n    inputTransformer.test()\n        .testSignal(InputSignal.InputUpdate(\"Hello World\")) {\n            // Verify state update\n            val state = lastData&lt;InputUiState&gt;()\n            assertEquals(\"Hello World\", state?.writtenText)\n\n            // Verify effect publication\n            val effect = lastEffect&lt;InputEffect.InputUpdate&gt;()\n            assertEquals(\"Hello World\", effect?.value)\n        }\n}\n\n@Test\nfun `color picker should handle background color update`() {\n    val colorPickerTransformer = ColorPickerTransformer()\n\n    colorPickerTransformer.test()\n        .testEffect(ColorPickerEffect.BackgroundColorUpdate(Color.Gray)) {\n            val state = lastData&lt;ColorPickerUiState&gt;()\n            assertEquals(Color.Gray, state?.backgroundColor)\n        }\n}\n</code></pre>"},{"location":"testing/#advanced-testing-with-assertions","title":"Advanced Testing with Assertions","text":""},{"location":"testing/#using-all-dataeffects","title":"Using All Data/Effects","text":"<pre><code>@Test\nfun `should track all data emissions`() {\n    val transformer = MultiDataTransformer()\n\n    transformer.test()\n        .testSignal(EmitMultipleDataSignal) {\n            val allUserData = allData&lt;UserData&gt;()\n            assertEquals(3, allUserData.size)\n\n            val allEffects = allEffects&lt;NotificationEffect&gt;()\n            assertTrue(allEffects.isNotEmpty())\n        }\n}\n</code></pre>"},{"location":"testing/#using-find-data-with-predicates","title":"Using Find Data with Predicates","text":"<pre><code>@Test\nfun `should find specific data with predicate`() {\n    val transformer = SearchTransformer()\n\n    transformer.test()\n        .testSignal(SearchSignal(\"query\")) {\n            val specificResult = findData&lt;SearchResult&gt; { \n                it.query == \"query\" &amp;&amp; it.resultCount &gt; 0 \n            }\n            assertNotNull(specificResult)\n\n            val nthResult = nthData&lt;SearchResult&gt;(1) // Second result\n            assertNotNull(nthResult)\n        }\n}\n</code></pre>"},{"location":"testing/#advanced-testing-patterns","title":"Advanced Testing Patterns","text":""},{"location":"testing/#testing-inter-transformer-communication","title":"Testing Inter-Transformer Communication","text":"<pre><code>@Test\nfun `should communicate between transformers correctly`() {\n    val providerTransformer = DataProviderTransformer()\n    val consumerTransformer = DataConsumerTransformer()\n\n    // Setup provider with mock data\n    providerTransformer.test()\n        .withData(DataProviderTransformer.dataContract, mockProviderData)\n        .testSignal(UpdateDataSignal(\"Test Data\")) {\n            assertTrue(hasData&lt;DataUpdated&gt;())\n        }\n\n    // Test consumer querying provider\n    consumerTransformer.test()\n        .withComputation(DataProviderTransformer.dataContract, mockProviderData)\n        .testSignal(RequestDataSignal) {\n            val data = lastData&lt;RequestedData&gt;()\n            assertEquals(\"Test Data\", data?.content)\n        }\n}\n</code></pre>"},{"location":"testing/#testing-time-dependent-operations","title":"Testing Time-Dependent Operations","text":"<pre><code>@Test\nfun `should handle delayed operations correctly`() {\n    val delayedTransformer = DelayedTransformer()\n\n    delayedTransformer.test()\n        .testSignal(StartDelayedOperationSignal) {\n            // Verify immediate response\n            assertTrue(hasData&lt;OperationStartedData&gt;())\n\n            // Verify delayed result appears\n            val delayedResult = lastData&lt;DelayedOperationCompletedData&gt;()\n            assertNotNull(delayedResult)\n        }\n}\n</code></pre>"},{"location":"testing/#testing-multiple-transformer-interactions","title":"Testing Multiple Transformer Interactions","text":"<pre><code>@Test\nfun `should handle multi-transformer workflow`() {\n    val orderTransformer = OrderTransformer()\n    val paymentTransformer = PaymentTransformer()\n    val inventoryTransformer = InventoryTransformer()\n\n    // Mock external dependencies\n    orderTransformer.test()\n        .withComputation(PaymentTransformer.processPaymentContract, paymentResult)\n        .withComputation(InventoryTransformer.reserveItemsContract, inventoryResult)\n        .testSignal(CreateOrderSignal(orderDetails)) {\n            assertTrue(hasEffect&lt;ValidateInventoryEffect&gt;())\n            assertTrue(hasEffect&lt;ProcessPaymentEffect&gt;())\n\n            val order = lastData&lt;OrderCreatedData&gt;()\n            assertEquals(OrderStatus.CREATED, order?.status)\n        }\n}\n</code></pre>"},{"location":"testing/#testing-utilities","title":"Testing Utilities","text":""},{"location":"testing/#custom-test-helpers","title":"Custom Test Helpers","text":"<pre><code>fun TransmissionTest.sendValidLoginSignal(): TransmissionTest {\n    return this.testSignal(UserLoginSignal(Credentials(\"user\", \"password\"))) {\n        // Validation logic can be here or separate\n    }\n}\n\nfun TransmissionTest.expectSuccessfulLogin() {\n    this.testSignal(UserLoginSignal(validCredentials)) {\n        val userData = lastData&lt;UserData&gt;()\n        assertTrue(userData?.isAuthenticated == true)\n        assertTrue(hasEffect&lt;NavigationEffect.GoToHome&gt;())\n    }\n}\n\n@Test\nfun `should login successfully with valid credentials`() {\n    val authTransformer = AuthTransformer()\n\n    authTransformer.test()\n        .expectSuccessfulLogin()\n}\n</code></pre>"},{"location":"testing/#parameterized-tests","title":"Parameterized Tests","text":"<pre><code>@ParameterizedTest\n@ValueSource(strings = [\"\", \" \", \"invalid-format\", \"too-long-input\"])\nfun `should reject invalid inputs`(invalidInput: String) {\n    val validationTransformer = ValidationTransformer()\n\n    validationTransformer.test()\n        .testSignal(ValidateInputSignal(invalidInput)) {\n            val result = lastData&lt;ValidationResult&gt;()\n            assertFalse(result?.isValid == true)\n            assertNotNull(result?.errorMessage)\n        }\n}\n</code></pre>"},{"location":"testing/#mock-transformers-for-testing","title":"Mock Transformers for Testing","text":"<pre><code>class MockExternalServiceTransformer(\n    private val shouldFail: Boolean = false\n) : Transformer() {\n\n    override val computations: Computations = computations {\n        register(ExternalServiceTransformer.getDataContract) {\n            if (shouldFail) {\n                throw RuntimeException(\"Service unavailable\")\n            } else {\n                \"Mock data\"\n            }\n        }\n    }\n}\n\n@Test\nfun `should handle external service failure`() {\n    val businessTransformer = BusinessTransformer()\n\n    businessTransformer.test()\n        .withComputation(ExternalServiceTransformer.getDataContract, null)\n        .testSignal(ProcessDataSignal) {\n            val error = lastData&lt;ErrorData&gt;()\n            assertTrue(error?.message?.contains(\"Service unavailable\") == true)\n        }\n}\n</code></pre>"},{"location":"testing/#best-practices","title":"Best Practices","text":""},{"location":"testing/#1-test-business-logic-not-implementation","title":"1. Test Business Logic, Not Implementation","text":"<pre><code>// Good - tests behavior\n@Test\nfun `should calculate order total correctly`() {\n    val orderTransformer = OrderTransformer()\n\n    orderTransformer.test()\n        .testSignal(CalculateOrderSignal(orderWithItems)) {\n            val total = lastData&lt;OrderTotal&gt;()\n            assertEquals(BigDecimal(\"150.00\"), total?.amount)\n        }\n}\n\n// Avoid - tests implementation details\n@Test\nfun `should call specific internal method`() {\n    // Testing internal method calls is fragile\n}\n</code></pre>"},{"location":"testing/#2-use-descriptive-test-names","title":"2. Use Descriptive Test Names","text":"<pre><code>// Good\n@Test\nfun `should reject order when inventory is insufficient`()\n\n@Test\nfun `should send welcome email after successful registration`()\n\n// Avoid\n@Test\nfun `test1()`()\n\n@Test\nfun `testOrderProcessing()`()\n</code></pre>"},{"location":"testing/#3-test-edge-cases","title":"3. Test Edge Cases","text":"<pre><code>@Test\nfun `should handle empty input gracefully`() {\n    val processor = DataProcessorTransformer()\n\n    processor.test()\n        .testSignal(ProcessDataSignal(emptyList())) {\n            val result = lastData&lt;ProcessingResult&gt;()\n            assertTrue(result?.isEmpty == true)\n        }\n}\n\n@Test\nfun `should handle null values correctly`() {\n    val transformer = NullSafeTransformer()\n\n    transformer.test()\n        .testSignal(ProcessNullableSignal(null)) {\n            val result = lastData&lt;SafeProcessingResult&gt;()\n            assertEquals(\"default\", result?.value)\n        }\n}\n</code></pre>"},{"location":"testing/#4-keep-tests-isolated","title":"4. Keep Tests Isolated","text":"<pre><code>// Good - each test is independent\n@Test\nfun `should process valid order`() {\n    val transformer = OrderTransformer()\n    // Test implementation\n}\n\n@Test\nfun `should reject invalid order`() {\n    val transformer = OrderTransformer() // Fresh instance\n    // Test implementation\n}\n\n// Avoid - shared state between tests\nclass OrderTransformerTest {\n    private val sharedTransformer = OrderTransformer() // Bad: shared state\n}\n</code></pre>"},{"location":"testing/#5-verify-both-positive-and-negative-cases","title":"5. Verify Both Positive and Negative Cases","text":"<pre><code>@Test\nfun `should succeed with valid data`() {\n    val transformer = DataTransformer()\n\n    transformer.test()\n        .testSignal(ValidDataSignal(validData)) {\n            assertTrue(hasData&lt;SuccessData&gt;())\n            assertFalse(hasData&lt;ErrorData&gt;())\n        }\n}\n\n@Test\nfun `should fail with invalid data`() {\n    val transformer = DataTransformer()\n\n    transformer.test()\n        .testSignal(InvalidDataSignal(invalidData)) {\n            assertTrue(hasData&lt;ErrorData&gt;())\n            assertFalse(hasData&lt;SuccessData&gt;())\n        }\n}\n\n@Test\nfun `should handle edge cases`() {\n    val transformer = DataTransformer()\n\n    transformer.test()\n        .testSignal(EdgeCaseSignal(edgeCaseData)) {\n            val result = lastData&lt;ProcessingResult&gt;()\n            // Verify boundary condition handling\n        }\n}\n</code></pre>"},{"location":"testing/#summary","title":"Summary","text":"<p>The Transmission testing framework provides a comprehensive API for testing your transformers:</p> <ul> <li>transformer.test() - Creates a TransmissionTest instance</li> <li>testSignal(signal) { assertions } - Tests signal handling</li> <li>testEffect(effect) { assertions } - Tests effect handling</li> <li>withData/withComputation/withCheckpoint - Mocking and setup</li> <li>lastData(), allData(), hasData() - Data assertions <li>lastEffect(), allEffects(), hasEffect() - Effect assertions <li>findData(predicate), nthData(index) - Advanced data queries <p>Use these tools to create comprehensive, maintainable tests that verify your business logic while remaining resilient to implementation changes.</p>"},{"location":"transformer/","title":"Transformer","text":"<p>A Transformer is the core component that processes transmissions and contains your business logic. Transformers receive Signals and Effects, process them, and produce Data or additional Effects.</p>"},{"location":"transformer/#basic-structure","title":"Basic Structure","text":"<pre><code>class MyTransformer : Transformer() {\n\n    override val handlers: Handlers = handlers {\n        // Define signal and effect handlers\n    }\n\n    override val computations: Computations = computations {\n        // Define computations for inter-transformer communication\n    }\n\n    override val executions: Executions = executions {\n        // Define executions for fire-and-forget operations\n    }\n}\n</code></pre>"},{"location":"transformer/#constructor-parameters","title":"Constructor Parameters","text":"<pre><code>open class Transformer(\n    identity: Contract.Identity = Contract.identity(),\n    dispatcher: CoroutineDispatcher = Dispatchers.Default,\n    private val capacity: Capacity = Capacity.Default\n)\n</code></pre> <ul> <li>identity: Unique identifier for the transformer (auto-generated if not provided)</li> <li>dispatcher: Coroutine dispatcher for processing (defaults to <code>Dispatchers.Default</code>)</li> <li>capacity: Buffer capacity for internal channels</li> </ul>"},{"location":"transformer/#handlers","title":"Handlers","text":"<p>Handlers define how your Transformer responds to incoming Signals and Effects.</p>"},{"location":"transformer/#signal-handlers","title":"Signal Handlers","text":"<pre><code>override val handlers: Handlers = handlers {\n    onSignal&lt;UserLoginSignal&gt; { signal -&gt;\n        // Process the login signal\n        val result = authenticateUser(signal.credentials)\n\n        if (result.isSuccess) {\n            send(UserData(result.user))\n            publish(NavigationEffect.GoToHome)\n        } else {\n            send(ErrorData(\"Login failed\"))\n        }\n    }\n}\n</code></pre>"},{"location":"transformer/#effect-handlers","title":"Effect Handlers","text":"<pre><code>override val handlers: Handlers = handlers {\n    onEffect&lt;RefreshDataEffect&gt; { effect -&gt;\n        // Handle refresh effect\n        val freshData = fetchFreshData()\n        send(DataRefreshedData(freshData))\n    }\n}\n</code></pre>"},{"location":"transformer/#complete-example-from-counter-sample","title":"Complete Example from Counter Sample","text":"<pre><code>class Worker(val id: String) : Transformer() {\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;CounterSignal.Lookup&gt; {\n            send(CounterData(\"Transformer $id updated data to ${compute(lookUpAndReturn, id)}\"))\n        }\n    }\n}\n</code></pre>"},{"location":"transformer/#communication-scope","title":"Communication Scope","text":"<p>Within handler lambdas, you have access to <code>CommunicationScope</code> which provides:</p>"},{"location":"transformer/#sending-data","title":"Sending Data","text":"<pre><code>// Send data to the router's data stream\nsend(UserData(user))\n</code></pre>"},{"location":"transformer/#publishing-effects","title":"Publishing Effects","text":"<pre><code>// Publish effect to other transformers\npublish(LoggingEffect(\"User logged in\"))\n\n// Publish effect to specific transformer\npublish(\n    effect = NotificationEffect(\"Welcome!\"),\n    identity = notificationTransformerIdentity\n)\n</code></pre>"},{"location":"transformer/#query-other-transformers","title":"Query Other Transformers","text":"<pre><code>// Compute value from another transformer\nval userData = compute(userDataContract)\n\n// Compute with arguments\nval validationResult = compute(validationContract, inputData)\n</code></pre>"},{"location":"transformer/#execute-operations","title":"Execute Operations","text":"<pre><code>// Fire-and-forget execution\nexecute(cleanupContract)\n\n// Execute with arguments\nexecute(logContract, \"User action performed\")\n</code></pre>"},{"location":"transformer/#data-holders","title":"Data Holders","text":"<p>Data Holders provide state management within Transformers:</p> <pre><code>class UserTransformer : Transformer() {\n\n    // Create a data holder with initial state\n    private val userHolder = dataHolder(\n        initialValue = UserState(),\n        contract = userStateContract\n    )\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;UpdateUserSignal&gt; { signal -&gt;\n            // Update the held state\n            userHolder.update { currentState -&gt;\n                currentState.copy(name = signal.newName)\n            }\n\n            // The updated state is automatically sent as Data\n        }\n\n        onSignal&lt;GetUserSignal&gt; {\n            // Access current state\n            val currentUser = userHolder.getValue()\n            send(CurrentUserData(currentUser))\n        }\n    }\n}\n</code></pre>"},{"location":"transformer/#data-holder-features","title":"Data Holder Features","text":"<ul> <li>Automatic Data Publishing: Updates are automatically sent to the data stream</li> <li>Thread-Safe: Updates are synchronized</li> <li>State Tracking: Previous states are tracked for debugging</li> </ul>"},{"location":"transformer/#creating-data-holders","title":"Creating Data Holders","text":"<pre><code>// Basic data holder\nval holder = dataHolder(initialValue = MyState(), contract = myContract)\n\n// Data holder without auto-publishing  \nval holder = dataHolder(\n    initialValue = MyState(), \n    contract = myContract,\n    publishUpdates = false\n)\n</code></pre>"},{"location":"transformer/#computations","title":"Computations","text":"<p>Computations enable inter-transformer communication for retrieving data:</p> <pre><code>class CalculatorTransformer : Transformer() {\n\n    override val computations: Computations = computations {\n        // Simple computation\n        register(currentValueContract) {\n            getCurrentCalculatorValue()\n        }\n\n        // Computation with arguments\n        register(calculateContract) { input: CalculationInput -&gt;\n            performCalculation(input)\n        }\n\n        // Cached computation (result is cached)\n        register(expensiveCalculationContract) {\n            expensiveOperation()\n        }\n    }\n}\n</code></pre>"},{"location":"transformer/#using-computations","title":"Using Computations","text":"<pre><code>override val handlers: Handlers = handlers {\n    onSignal&lt;DisplayResultSignal&gt; {\n        // Query another transformer's computation\n        val currentValue = compute(currentValueContract)\n        send(DisplayData(currentValue))\n    }\n\n    onSignal&lt;PerformCalculationSignal&gt; { signal -&gt;\n        // Query with arguments\n        val result = compute(calculateContract, signal.input)\n        send(CalculationResultData(result))\n    }\n}\n</code></pre>"},{"location":"transformer/#executions","title":"Executions","text":"<p>Executions are fire-and-forget operations for side effects:</p> <pre><code>class LoggingTransformer : Transformer() {\n\n    override val executions: Executions = executions {\n        // Simple execution\n        register(logMessageContract) {\n            writeToLogFile(\"Message logged\")\n        }\n\n        // Execution with arguments\n        register(logWithLevelContract) { logEntry: LogEntry -&gt;\n            writeToLogFile(logEntry.level, logEntry.message)\n        }\n    }\n}\n</code></pre>"},{"location":"transformer/#using-executions","title":"Using Executions","text":"<pre><code>override val handlers: Handlers = handlers {\n    onSignal&lt;UserActionSignal&gt; { signal -&gt;\n        // Fire-and-forget logging\n        execute(logMessageContract)\n\n        // With arguments\n        execute(logWithLevelContract, LogEntry(LogLevel.INFO, \"User action: ${signal.action}\"))\n\n        // Continue with main logic\n        send(ActionCompletedData(signal.action))\n    }\n}\n</code></pre>"},{"location":"transformer/#advanced-features","title":"Advanced Features","text":""},{"location":"transformer/#checkpoint-tracking-experimental","title":"Checkpoint Tracking (Experimental)","text":"<p>Checkpoints enable debugging and flow control:</p> <pre><code>@OptIn(ExperimentalTransmissionApi::class)\nclass ComplexTransformer : Transformer() {\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;ProcessDataSignal&gt; { signal -&gt;\n            // Pause execution at checkpoint\n            val validatedData = pauseOn(validationCheckpoint)\n\n            // Continue processing\n            send(ProcessedData(validatedData))\n        }\n\n        onEffect&lt;ValidationCompleteEffect&gt; { effect -&gt;\n            // Validate checkpoint with result\n            validate(validationCheckpoint, effect.validatedData)\n        }\n    }\n\n    companion object {\n        val validationCheckpoint = Contract.checkpointWithArgs&lt;ValidatedData&gt;()\n    }\n}\n</code></pre>"},{"location":"transformer/#custom-error-handling","title":"Custom Error Handling","text":"<pre><code>class SafeTransformer : Transformer() {\n\n    override fun onError(throwable: Throwable) {\n        // Handle errors that occur in this transformer\n        publish(ErrorEffect(\"Transformer error: ${throwable.message}\"))\n    }\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;RiskyOperationSignal&gt; { signal -&gt;\n            try {\n                val result = riskyOperation(signal.data)\n                send(SuccessData(result))\n            } catch (e: Exception) {\n                send(ErrorData(e.message))\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"transformer/#lifecycle-management","title":"Lifecycle Management","text":"<pre><code>class ResourceTransformer : Transformer() {\n\n    private val database = openDatabase()\n\n    override fun onCleared() {\n        // Cleanup when transformer is cleared\n        database.close()\n        super.onCleared()\n    }\n}\n</code></pre>"},{"location":"transformer/#complete-example-from-components-sample","title":"Complete Example from Components Sample","text":"<pre><code>class InputTransformer(\n    private val defaultDispatcher: CoroutineDispatcher\n) : Transformer(dispatcher = defaultDispatcher) {\n\n    private val holder = dataHolder(InputUiState(), holderContract)\n\n    override val computations: Computations = computations {\n        register(writtenInputContract) {\n            delay(1.seconds)\n            WrittenInput(holder.getValue().writtenText)\n        }\n        register(writtenInputWithArgs) {\n            WrittenInput(it)\n        }\n    }\n\n    @OptIn(ExperimentalTransmissionApi::class)\n    override val handlers: Handlers = handlers {\n        onSignal&lt;InputSignal.InputUpdate&gt; { signal -&gt;\n            holder.update { it.copy(writtenText = signal.value) }\n            val color = pauseOn(colorCheckpoint)\n            send(\n                effect = ColorPickerEffect.SelectedColorUpdate(color),\n                identity = multiOutputTransformerIdentity\n            )\n            publish(effect = InputEffect.InputUpdate(signal.value))\n        }\n        onEffect&lt;ColorPickerEffect.BackgroundColorUpdate&gt; { effect -&gt;\n            validate(colorCheckpoint, effect.color)\n            holder.update { it.copy(backgroundColor = effect.color) }\n        }\n    }\n\n    companion object {\n        val writtenInputWithArgs = Contract.computationWithArgs&lt;String, WrittenInput&gt;()\n        val writtenInputContract = Contract.computation&lt;WrittenInput&gt;()\n        val holderContract = Contract.dataHolder&lt;InputUiState&gt;()\n        val colorCheckpoint = Contract.checkpointWithArgs&lt;Color&gt;()\n    }\n}\n</code></pre>"},{"location":"transformer/#best-practices","title":"Best Practices","text":""},{"location":"transformer/#1-single-responsibility","title":"1. Single Responsibility","text":"<p>Keep each Transformer focused on a specific domain:</p> <pre><code>// Good - focused on user authentication\nclass AuthTransformer : Transformer()\n\n// Good - focused on data caching  \nclass CacheTransformer : Transformer()\n\n// Avoid - mixed responsibilities\nclass AuthAndCacheTransformer : Transformer()\n</code></pre>"},{"location":"transformer/#2-immutable-state","title":"2. Immutable State","text":"<p>Use immutable data classes for state:</p> <pre><code>data class UserState(\n    val user: User? = null,\n    val isLoading: Boolean = false,\n    val error: String? = null\n)\n</code></pre>"},{"location":"transformer/#3-error-handling","title":"3. Error Handling","text":"<p>Handle errors gracefully:</p> <pre><code>onSignal&lt;LoadDataSignal&gt; { signal -&gt;\n    try {\n        val data = loadData(signal.id)\n        send(DataLoadedData(data))\n    } catch (e: Exception) {\n        send(ErrorData(\"Failed to load data: ${e.message}\"))\n    }\n}\n</code></pre>"},{"location":"transformer/#4-use-contracts-for-communication","title":"4. Use Contracts for Communication","text":"<p>Define contracts for inter-transformer communication:</p> <pre><code>companion object {\n    val userDataContract = Contract.computation&lt;UserData&gt;()\n    val validateUserContract = Contract.computationWithArgs&lt;User, Boolean&gt;()\n}\n</code></pre>"},{"location":"transformer_communication/","title":"Transformer Communication","text":"<p>Transformers in the Transmission library can communicate with each other through several mechanisms: Effects, Computations, Executions, and Checkpoints. This enables complex business logic flows while maintaining loose coupling between components.</p>"},{"location":"transformer_communication/#communication-methods","title":"Communication Methods","text":""},{"location":"transformer_communication/#1-effects-asynchronous-communication","title":"1. Effects (Asynchronous Communication)","text":"<p>Effects are the primary way for Transformers to communicate asynchronously.</p>"},{"location":"transformer_communication/#publishing-effects","title":"Publishing Effects","text":"<pre><code>class SourceTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;TriggerActionSignal&gt; { signal -&gt;\n            // Publish effect to all listening transformers\n            publish(DataProcessingEffect(signal.data))\n        }\n    }\n}\n\nclass TargetTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onEffect&lt;DataProcessingEffect&gt; { effect -&gt;\n            // Handle the effect\n            val processedData = processData(effect.data)\n            send(ProcessedData(processedData))\n        }\n    }\n}\n</code></pre>"},{"location":"transformer_communication/#targeted-effects","title":"Targeted Effects","text":"<pre><code>class SpecificTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;SendToSpecificSignal&gt; { signal -&gt;\n            // Send effect to a specific transformer\n            publish(\n                effect = SpecificEffect(signal.data),\n                identity = targetTransformerIdentity\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"transformer_communication/#2-computations-synchronous-queries","title":"2. Computations (Synchronous Queries)","text":"<p>Computations allow one Transformer to query data from another synchronously.</p>"},{"location":"transformer_communication/#simple-computations","title":"Simple Computations","text":"<pre><code>class DataProviderTransformer : Transformer() {\n    private var currentData = \"Initial State\"\n\n    override val computations: Computations = computations {\n        register(getCurrentDataContract) {\n            currentData\n        }\n\n        register(getDataStatusContract) {\n            DataStatus(\n                value = currentData,\n                lastUpdated = System.currentTimeMillis(),\n                isValid = currentData.isNotEmpty()\n            )\n        }\n    }\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;UpdateDataSignal&gt; { signal -&gt;\n            currentData = signal.newData\n            send(DataUpdated(currentData))\n        }\n    }\n\n    companion object {\n        val getCurrentDataContract = Contract.computation&lt;String&gt;()\n        val getDataStatusContract = Contract.computation&lt;DataStatus&gt;()\n    }\n}\n\nclass DataConsumerTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;ProcessDataSignal&gt; {\n            // Query data from another transformer\n            val currentData = compute(DataProviderTransformer.getCurrentDataContract)\n            val status = compute(DataProviderTransformer.getDataStatusContract)\n\n            if (status.isValid) {\n                val result = processData(currentData)\n                send(ProcessingResult(result))\n            } else {\n                send(ProcessingError(\"Invalid data state\"))\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"transformer_communication/#computations-with-arguments","title":"Computations with Arguments","text":"<pre><code>class CalculationTransformer : Transformer() {\n    override val computations: Computations = computations {\n        register(calculateSumContract) { numbers: List&lt;Int&gt; -&gt;\n            numbers.sum()\n        }\n\n        register(formatCurrencyContract) { amount: Double -&gt;\n            \"%.2f USD\".format(amount)\n        }\n\n        register(validateDataContract) { data: InputData -&gt;\n            ValidationResult(\n                isValid = data.isNotEmpty() &amp;&amp; data.isNumeric(),\n                errors = validateInput(data)\n            )\n        }\n    }\n\n    companion object {\n        val calculateSumContract = Contract.computationWithArgs&lt;List&lt;Int&gt;, Int&gt;()\n        val formatCurrencyContract = Contract.computationWithArgs&lt;Double, String&gt;()\n        val validateDataContract = Contract.computationWithArgs&lt;InputData, ValidationResult&gt;()\n    }\n}\n\nclass BusinessLogicTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;ProcessOrderSignal&gt; { signal -&gt;\n            // Validate input data\n            val validation = compute(CalculationTransformer.validateDataContract, signal.orderData)\n\n            if (!validation.isValid) {\n                send(OrderValidationFailed(validation.errors))\n                return@onSignal\n            }\n\n            // Calculate totals\n            val itemPrices = signal.orderData.items.map { it.price }\n            val total = compute(CalculationTransformer.calculateSumContract, itemPrices)\n\n            // Format for display\n            val formattedTotal = compute(CalculationTransformer.formatCurrencyContract, total.toDouble())\n\n            send(OrderProcessed(signal.orderData.id, formattedTotal))\n        }\n    }\n}\n</code></pre>"},{"location":"transformer_communication/#3-executions-fire-and-forget-operations","title":"3. Executions (Fire-and-Forget Operations)","text":"<p>Executions are used for side effects that don't return values.</p> <pre><code>class AuditTransformer : Transformer() {\n    override val executions: Executions = executions {\n        register(logUserActionContract) { action: UserAction -&gt;\n            writeAuditLog(action.userId, action.action, action.timestamp)\n        }\n\n        register(sendNotificationContract) { notification: Notification -&gt;\n            sendPushNotification(notification.userId, notification.message)\n        }\n\n        register(updateAnalyticsContract) { event: AnalyticsEvent -&gt;\n            analyticsService.track(event.name, event.properties)\n        }\n    }\n\n    companion object {\n        val logUserActionContract = Contract.executionWithArgs&lt;UserAction&gt;()\n        val sendNotificationContract = Contract.executionWithArgs&lt;Notification&gt;()\n        val updateAnalyticsContract = Contract.executionWithArgs&lt;AnalyticsEvent&gt;()\n    }\n}\n\nclass UserInteractionTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;UserClickedButtonSignal&gt; { signal -&gt;\n            // Fire-and-forget operations\n            execute(AuditTransformer.logUserActionContract, UserAction(\n                userId = signal.userId,\n                action = \"button_click:${signal.buttonId}\",\n                timestamp = System.currentTimeMillis()\n            ))\n\n            execute(AuditTransformer.updateAnalyticsContract, AnalyticsEvent(\n                name = \"button_click\",\n                properties = mapOf(\"button_id\" to signal.buttonId)\n            ))\n\n            // Continue with main business logic\n            send(ButtonClickProcessed(signal.buttonId))\n        }\n    }\n}\n</code></pre>"},{"location":"transformer_communication/#complex-communication-patterns","title":"Complex Communication Patterns","text":""},{"location":"transformer_communication/#chain-of-responsibility","title":"Chain of Responsibility","text":"<pre><code>class ValidationChainTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;ValidateDataSignal&gt; { signal -&gt;\n            // Start validation chain\n            publish(ValidateFormatEffect(signal.data))\n        }\n\n        onEffect&lt;ValidateFormatEffect&gt; { effect -&gt;\n            if (isValidFormat(effect.data)) {\n                publish(ValidateBusinessRulesEffect(effect.data))\n            } else {\n                send(ValidationFailed(\"Invalid format\"))\n            }\n        }\n\n        onEffect&lt;ValidateBusinessRulesEffect&gt; { effect -&gt;\n            if (passesBusinessRules(effect.data)) {\n                publish(ValidateSecurityEffect(effect.data))\n            } else {\n                send(ValidationFailed(\"Business rules violation\"))\n            }\n        }\n\n        onEffect&lt;ValidateSecurityEffect&gt; { effect -&gt;\n            if (isSecure(effect.data)) {\n                send(ValidationPassed(effect.data))\n            } else {\n                send(ValidationFailed(\"Security check failed\"))\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"transformer_communication/#observer-pattern","title":"Observer Pattern","text":"<pre><code>class EventBroadcasterTransformer : Transformer() {\n    private val subscribersHolder = dataHolder(\n        initialValue = SubscriberState(),\n        contract = subscriberContract\n    )\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;SubscribeToEventsSignal&gt; { signal -&gt;\n            subscribersHolder.update { state -&gt;\n                state.copy(subscribers = state.subscribers + signal.subscriberId)\n            }\n        }\n\n        onSignal&lt;BroadcastEventSignal&gt; { signal -&gt;\n            val subscribers = subscribersHolder.getValue().subscribers\n\n            subscribers.forEach { subscriberId -&gt;\n                publish(EventBroadcastEffect(subscriberId, signal.event))\n            }\n        }\n    }\n\n    companion object {\n        val subscriberContract = Contract.dataHolder&lt;SubscriberState&gt;()\n    }\n}\n\nclass EventListenerTransformer(private val listenerId: String) : Transformer() {\n    override val handlers: Handlers = handlers {\n        onEffect&lt;EventBroadcastEffect&gt; { effect -&gt;\n            if (effect.subscriberId == listenerId) {\n                // Handle the broadcasted event\n                handleEvent(effect.event)\n            }\n        }\n    }\n\n    private suspend fun CommunicationScope.handleEvent(event: Event) {\n        when (event.type) {\n            \"user_action\" -&gt; send(UserActionReceived(event.data))\n            \"system_update\" -&gt; send(SystemUpdateReceived(event.data))\n        }\n    }\n}\n</code></pre>"},{"location":"transformer_communication/#state-machine-communication","title":"State Machine Communication","text":"<pre><code>class OrderStateMachineTransformer : Transformer() {\n    private val orderStateHolder = dataHolder(\n        initialValue = OrderState.Pending,\n        contract = orderStateContract\n    )\n\n    override val computations: Computations = computations {\n        register(getCurrentOrderStateContract) {\n            orderStateHolder.getValue()\n        }\n\n        register(canTransitionToContract) { targetState: OrderState -&gt;\n            val currentState = orderStateHolder.getValue()\n            isValidTransition(currentState, targetState)\n        }\n    }\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;ProcessOrderSignal&gt; { signal -&gt;\n            val currentState = orderStateHolder.getValue()\n\n            when (currentState) {\n                is OrderState.Pending -&gt; {\n                    orderStateHolder.update { OrderState.Processing }\n                    publish(StartOrderProcessingEffect(signal.orderId))\n                }\n                is OrderState.Processing -&gt; {\n                    send(OrderAlreadyProcessing(signal.orderId))\n                }\n                is OrderState.Completed -&gt; {\n                    send(OrderAlreadyCompleted(signal.orderId))\n                }\n            }\n        }\n\n        onEffect&lt;OrderProcessingCompleteEffect&gt; { effect -&gt;\n            orderStateHolder.update { OrderState.Completed }\n            publish(OrderCompletedEffect(effect.orderId))\n        }\n    }\n\n    companion object {\n        val orderStateContract = Contract.dataHolder&lt;OrderState&gt;()\n        val getCurrentOrderStateContract = Contract.computation&lt;OrderState&gt;()\n        val canTransitionToContract = Contract.computationWithArgs&lt;OrderState, Boolean&gt;()\n    }\n}\n\nsealed class OrderState : Transmission.Data {\n    object Pending : OrderState()\n    object Processing : OrderState()\n    object Completed : OrderState()\n}\n</code></pre>"},{"location":"transformer_communication/#examples-from-samples","title":"Examples from Samples","text":""},{"location":"transformer_communication/#components-sample-communication","title":"Components Sample Communication","text":"<pre><code>@OptIn(ExperimentalTransmissionApi::class)\nclass InputTransformer : Transformer() {\n    private val holder = dataHolder(InputUiState(), holderContract)\n\n    override val computations: Computations = computations {\n        register(writtenInputContract) {\n            delay(1.seconds)\n            WrittenInput(holder.getValue().writtenText)\n        }\n        register(writtenInputWithArgs) {\n            WrittenInput(it)\n        }\n    }\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;InputSignal.InputUpdate&gt; { signal -&gt;\n            holder.update { it.copy(writtenText = signal.value) }\n\n            // Checkpoint-based communication\n            val color = pauseOn(colorCheckpoint)\n\n            // Send effect to specific transformer\n            send(\n                effect = ColorPickerEffect.SelectedColorUpdate(color),\n                identity = multiOutputTransformerIdentity\n            )\n\n            // Broadcast effect to all listeners\n            publish(effect = InputEffect.InputUpdate(signal.value))\n        }\n\n        onEffect&lt;ColorPickerEffect.BackgroundColorUpdate&gt; { effect -&gt;\n            validate(colorCheckpoint, effect.color)\n            holder.update { it.copy(backgroundColor = effect.color) }\n        }\n    }\n}\n\nclass ColorPickerTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;ColorPickerSignal.ColorSelected&gt; { signal -&gt;\n            // Respond to color selection\n            publish(ColorPickerEffect.BackgroundColorUpdate(signal.color))\n        }\n\n        onEffect&lt;ColorPickerEffect.SelectedColorUpdate&gt; { effect -&gt;\n            // Handle incoming color update from InputTransformer\n            processSelectedColor(effect.color)\n        }\n    }\n}\n</code></pre>"},{"location":"transformer_communication/#advanced-communication-patterns","title":"Advanced Communication Patterns","text":""},{"location":"transformer_communication/#request-response-pattern","title":"Request-Response Pattern","text":"<pre><code>class ServiceTransformer : Transformer() {\n    private val pendingRequests = mutableMapOf&lt;String, String&gt;()\n\n    override val handlers: Handlers = handlers {\n        onEffect&lt;ServiceRequestEffect&gt; { effect -&gt;\n            val requestId = generateRequestId()\n            pendingRequests[requestId] = effect.requesterId\n\n            // Process request\n            val result = processServiceRequest(effect.request)\n\n            // Send response back to requester\n            publish(ServiceResponseEffect(\n                requestId = requestId,\n                response = result,\n                targetTransformerId = effect.requesterId\n            ))\n        }\n    }\n}\n\nclass ClientTransformer(private val transformerId: String) : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;RequestServiceSignal&gt; { signal -&gt;\n            // Send request to service\n            publish(ServiceRequestEffect(\n                request = signal.request,\n                requesterId = transformerId\n            ))\n        }\n\n        onEffect&lt;ServiceResponseEffect&gt; { effect -&gt;\n            if (effect.targetTransformerId == transformerId) {\n                // Handle response\n                send(ServiceResponseReceived(effect.response))\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"transformer_communication/#pipeline-pattern","title":"Pipeline Pattern","text":"<pre><code>class PipelineStage1Transformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;StartPipelineSignal&gt; { signal -&gt;\n            val stage1Result = processStage1(signal.input)\n            publish(Stage1CompleteEffect(stage1Result))\n        }\n    }\n}\n\nclass PipelineStage2Transformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onEffect&lt;Stage1CompleteEffect&gt; { effect -&gt;\n            val stage2Result = processStage2(effect.data)\n            publish(Stage2CompleteEffect(stage2Result))\n        }\n    }\n}\n\nclass PipelineStage3Transformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onEffect&lt;Stage2CompleteEffect&gt; { effect -&gt;\n            val finalResult = processStage3(effect.data)\n            send(PipelineCompleted(finalResult))\n        }\n    }\n}\n</code></pre>"},{"location":"transformer_communication/#mediator-pattern","title":"Mediator Pattern","text":"<pre><code>class MediatorTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onEffect&lt;ComponentAEvent&gt; { effect -&gt;\n            // Mediate between Component A and Component B\n            val transformedData = transformDataForB(effect.data)\n            publish(ComponentBCommand(transformedData))\n        }\n\n        onEffect&lt;ComponentBEvent&gt; { effect -&gt;\n            // Mediate between Component B and Component A\n            val transformedData = transformDataForA(effect.data)\n            publish(ComponentACommand(transformedData))\n        }\n\n        onEffect&lt;ComponentACommand&gt; { effect -&gt;\n            // Forward command to Component A\n            publish(ProcessComponentAEffect(effect.data))\n        }\n\n        onEffect&lt;ComponentBCommand&gt; { effect -&gt;\n            // Forward command to Component B  \n            publish(ProcessComponentBEffect(effect.data))\n        }\n    }\n}\n</code></pre>"},{"location":"transformer_communication/#error-handling-in-communication","title":"Error Handling in Communication","text":""},{"location":"transformer_communication/#safe-computation-calls","title":"Safe Computation Calls","text":"<pre><code>class SafeCommunicationTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        onSignal&lt;SafeQuerySignal&gt; {\n            try {\n                val result = compute(DataProviderTransformer.dataContract)\n                send(QuerySuccessful(result))\n            } catch (e: Exception) {\n                send(QueryFailed(\"Failed to compute data: ${e.message}\"))\n                execute(LoggingTransformer.logErrorContract, e.message)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"transformer_communication/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<pre><code>class CircuitBreakerTransformer : Transformer() {\n    private val circuitState = dataHolder(\n        initialValue = CircuitState.Closed,\n        contract = circuitStateContract\n    )\n\n    override val handlers: Handlers = handlers {\n        onSignal&lt;CallExternalServiceSignal&gt; { signal -&gt;\n            val currentState = circuitState.getValue()\n\n            when (currentState) {\n                is CircuitState.Closed -&gt; {\n                    try {\n                        val result = callExternalService(signal.request)\n                        send(ServiceCallSuccessful(result))\n                    } catch (e: Exception) {\n                        circuitState.update { CircuitState.Open(System.currentTimeMillis()) }\n                        send(ServiceCallFailed(\"Service unavailable\"))\n                    }\n                }\n                is CircuitState.Open -&gt; {\n                    if (System.currentTimeMillis() - currentState.openedAt &gt; CIRCUIT_TIMEOUT) {\n                        circuitState.update { CircuitState.HalfOpen }\n                        // Retry the call\n                        onSignal(signal)\n                    } else {\n                        send(ServiceCallFailed(\"Circuit breaker is open\"))\n                    }\n                }\n                is CircuitState.HalfOpen -&gt; {\n                    try {\n                        val result = callExternalService(signal.request)\n                        circuitState.update { CircuitState.Closed }\n                        send(ServiceCallSuccessful(result))\n                    } catch (e: Exception) {\n                        circuitState.update { CircuitState.Open(System.currentTimeMillis()) }\n                        send(ServiceCallFailed(\"Service still unavailable\"))\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"transformer_communication/#best-practices","title":"Best Practices","text":""},{"location":"transformer_communication/#1-use-appropriate-communication-methods","title":"1. Use Appropriate Communication Methods","text":"<pre><code>// Use Effects for asynchronous notifications\npublish(UserLoggedInEffect(user.id))\n\n// Use Computations for data queries\nval userData = compute(UserTransformer.getCurrentUserContract)\n\n// Use Executions for fire-and-forget operations\nexecute(AuditTransformer.logActionContract, action)\n</code></pre>"},{"location":"transformer_communication/#2-design-clear-interfaces","title":"2. Design Clear Interfaces","text":"<pre><code>// Good - clear, specific contracts\nobject OrderContracts {\n    val getCurrentOrder = Contract.computation&lt;Order?&gt;()\n    val calculateOrderTotal = Contract.computationWithArgs&lt;OrderItems, BigDecimal&gt;()\n    val validateOrder = Contract.computationWithArgs&lt;Order, ValidationResult&gt;()\n    val saveOrder = Contract.executionWithArgs&lt;Order&gt;()\n}\n\n// Avoid - vague, generic contracts\nval dataContract = Contract.computation&lt;Any&gt;()\nval processContract = Contract.computationWithArgs&lt;Any, Any&gt;()\n</code></pre>"},{"location":"transformer_communication/#3-handle-communication-failures","title":"3. Handle Communication Failures","text":"<pre><code>override val handlers: Handlers = handlers {\n    onSignal&lt;QueryDataSignal&gt; {\n        try {\n            val data = compute(DataProviderTransformer.dataContract)\n            send(DataQuerySuccessful(data))\n        } catch (e: Exception) {\n            send(DataQueryFailed(\"Communication failed: ${e.message}\"))\n            execute(LoggingTransformer.logErrorContract, \"Query failed: ${e.message}\")\n        }\n    }\n}\n</code></pre>"},{"location":"transformer_communication/#4-maintain-loose-coupling","title":"4. Maintain Loose Coupling","text":"<pre><code>// Good - communicates through contracts\nval userData = compute(UserContracts.getCurrentUser)\n\n// Avoid - direct references\nval userData = userTransformer.getCurrentUser() // Direct coupling\n</code></pre>"},{"location":"transformer_communication/#5-document-communication-flows","title":"5. Document Communication Flows","text":"<pre><code>/**\n * Order Processing Flow:\n * 1. OrderTransformer receives CreateOrderSignal\n * 2. Publishes ValidateOrderEffect \n * 3. ValidationTransformer validates and publishes ProcessPaymentEffect\n * 4. PaymentTransformer processes payment and publishes SaveOrderEffect\n * 5. OrderTransformer saves order and sends OrderCreatedData\n */\nclass OrderTransformer : Transformer() {\n    // Implementation...\n}\n</code></pre>"},{"location":"transmissions/","title":"Transmissions","text":"<p>A Transmission is the fundamental unit of information in the Transmission library. All communication between components flows through these transmission types.</p>"},{"location":"transmissions/#the-three-types","title":"The Three Types","text":"<pre><code>sealed interface Transmission {\n    interface Signal : Transmission\n    interface Effect : Transmission  \n    interface Data : Transmission\n}\n</code></pre>"},{"location":"transmissions/#signal","title":"Signal","text":"<p>Signals represent input from UI or external events that should trigger business logic processing.</p>"},{"location":"transmissions/#characteristics","title":"Characteristics","text":"<ul> <li>Entry point for user interactions</li> <li>Processed by TransmissionRouter</li> <li>Distributed to relevant Transformers</li> <li>Should be immutable data classes or objects</li> </ul>"},{"location":"transmissions/#examples","title":"Examples","text":"<pre><code>// Simple signal\ndata object RefreshSignal : Transmission.Signal\n\n// Signal with data\ndata class SearchSignal(val query: String) : Transmission.Signal\n\n// Sealed interface for grouped signals\nsealed interface CounterSignal : Transmission.Signal {\n    data object Increment : CounterSignal\n    data object Decrement : CounterSignal\n    data class SetValue(val value: Int) : CounterSignal\n}\n</code></pre>"},{"location":"transmissions/#from-counter-sample","title":"From Counter Sample","text":"<pre><code>sealed interface CounterSignal : Transmission.Signal {\n    data object Lookup : CounterSignal\n}\n</code></pre>"},{"location":"transmissions/#from-components-sample","title":"From Components Sample","text":"<pre><code>sealed interface InputSignal : Transmission.Signal {\n    data class InputUpdate(val value: String) : InputSignal\n}\n\nsealed interface ColorPickerSignal : Transmission.Signal {\n    data class ColorSelected(val color: Color) : ColorPickerSignal\n}\n</code></pre>"},{"location":"transmissions/#effect","title":"Effect","text":"<p>Effects represent side effects or intermediate processing steps that can trigger additional business logic.</p>"},{"location":"transmissions/#characteristics_1","title":"Characteristics","text":"<ul> <li>Created from Signals or other Effects</li> <li>Can trigger further processing</li> <li>Represent intermediate states in business logic</li> <li>Can be sent between Transformers</li> </ul>"},{"location":"transmissions/#examples_1","title":"Examples","text":"<pre><code>// Logging effect\ndata class LogEffect(val message: String, val level: LogLevel) : Transmission.Effect\n\n// Navigation effect  \ndata class NavigateEffect(val destination: String) : Transmission.Effect\n\n// Network effect\nsealed interface NetworkEffect : Transmission.Effect {\n    data class LoadData(val url: String) : NetworkEffect\n    data class SaveData(val data: Any) : NetworkEffect\n}\n</code></pre>"},{"location":"transmissions/#from-components-sample_1","title":"From Components Sample","text":"<pre><code>sealed interface InputEffect : Transmission.Effect {\n    data class InputUpdate(val value: String) : InputEffect\n}\n\nsealed interface ColorPickerEffect : Transmission.Effect {\n    data class SelectedColorUpdate(val color: Color) : ColorPickerEffect\n    data class BackgroundColorUpdate(val color: Color) : ColorPickerEffect\n}\n</code></pre>"},{"location":"transmissions/#data","title":"Data","text":"<p>Data represents the final result of business logic processing, ready for consumption by UI or other components.</p>"},{"location":"transmissions/#characteristics_2","title":"Characteristics","text":"<ul> <li>Final output of Transformer processing</li> <li>Consumed by UI components</li> <li>Should represent complete, ready-to-use information</li> <li>Flows through the router's data stream</li> </ul>"},{"location":"transmissions/#examples_2","title":"Examples","text":"<pre><code>// Simple data\ndata class UserData(val id: String, val name: String) : Transmission.Data\n\n// UI state data\ndata class CounterData(val count: Int, val isLoading: Boolean) : Transmission.Data\n\n// List data\ndata class ItemListData(val items: List&lt;Item&gt;) : Transmission.Data\n</code></pre>"},{"location":"transmissions/#from-counter-sample_1","title":"From Counter Sample","text":"<pre><code>data class CounterData(val id: String) : Transmission.Data\n</code></pre>"},{"location":"transmissions/#from-components-sample_2","title":"From Components Sample","text":"<pre><code>data class InputUiState(\n    val writtenText: String = \"\",\n    val backgroundColor: Color = Color.White\n) : Transmission.Data\n</code></pre>"},{"location":"transmissions/#flow-relationships","title":"Flow Relationships","text":"<p>The relationship between these types follows predictable patterns:</p> <pre><code>graph TD\n    UI[UI Layer] --&gt; |User Input| S[Signal]\n    S --&gt; |Processing| E1[Effect]\n    S --&gt; |Direct Result| D1[Data]\n    E1 --&gt; |Further Processing| E2[Effect]\n    E1 --&gt; |Final Result| D2[Data]\n    E2 --&gt; |Chain Processing| E3[Effect]\n    E2 --&gt; |Final Result| D3[Data]\n    D1 --&gt; |Consumption| UI\n    D2 --&gt; |Consumption| UI\n    D3 --&gt; |Consumption| UI</code></pre>"},{"location":"transmissions/#processing-in-transformers","title":"Processing in Transformers","text":"<p>Here's how transmissions are processed within Transformers:</p> <pre><code>class ExampleTransformer : Transformer() {\n    override val handlers: Handlers = handlers {\n        // Handle incoming Signal\n        onSignal&lt;SearchSignal&gt; { signal -&gt;\n            // Can produce Effects\n            publish(LogEffect(\"Searching for: ${signal.query}\", LogLevel.INFO))\n\n            // Can produce Data directly\n            send(SearchResultsData(searchResults = performSearch(signal.query)))\n        }\n\n        // Handle incoming Effect  \n        onEffect&lt;LogEffect&gt; { effect -&gt;\n            // Process the effect\n            logger.log(effect.level, effect.message)\n\n            // Can produce other Effects\n            if (effect.level == LogLevel.ERROR) {\n                publish(NotificationEffect(\"Error occurred\"))\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"transmissions/#best-practices","title":"Best Practices","text":""},{"location":"transmissions/#signal-design","title":"Signal Design","text":"<ul> <li>Keep signals simple and focused</li> <li>Use sealed interfaces for related signals</li> <li>Include only necessary data</li> <li>Make them immutable</li> </ul> <pre><code>// Good\nsealed interface UserSignal : Transmission.Signal {\n    data class Login(val credentials: Credentials) : UserSignal\n    data object Logout : UserSignal\n}\n\n// Avoid\ndata class UserSignal(\n    val action: String, // String-based actions are error-prone\n    val data: Any?      // Generic data is not type-safe\n) : Transmission.Signal\n</code></pre>"},{"location":"transmissions/#effect-design","title":"Effect Design","text":"<ul> <li>Use effects for side effects and intermediate processing</li> <li>Chain effects for complex workflows</li> <li>Keep effects focused on single responsibilities</li> </ul> <pre><code>// Good - focused effects\ndata class ValidateInputEffect(val input: String) : Transmission.Effect\ndata class SaveDataEffect(val data: UserData) : Transmission.Effect\n\n// Better - sealed interface for related effects\nsealed interface UserEffect : Transmission.Effect {\n    data class Validate(val input: String) : UserEffect\n    data class Save(val data: UserData) : UserEffect\n    data class Delete(val id: String) : UserEffect\n}\n</code></pre>"},{"location":"transmissions/#data-design","title":"Data Design","text":"<ul> <li>Make data complete and ready for consumption</li> <li>Include all necessary information for UI</li> <li>Keep data immutable</li> </ul> <pre><code>// Good - complete UI state\ndata class ProfileData(\n    val user: User,\n    val isLoading: Boolean,\n    val error: String?\n) : Transmission.Data\n\n// Avoid - incomplete information\ndata class ProfileData(val userId: String) : Transmission.Data // UI needs more info\n</code></pre>"}]}